package com.ibexlab.simple_pay_api.device.centerm;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageInfo;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Environment;
import android.os.IBinder;
import android.os.RemoteException;
import android.util.Log;

import com.centerm.smartpos.aidl.newprinter.AidlNewPrinter;
import com.centerm.smartpos.aidl.newprinter.PrinterState;
import com.centerm.smartpos.aidl.pboc.AidlCheckCardListener;
import com.centerm.smartpos.aidl.pboc.AidlEMVL2;
import com.centerm.smartpos.aidl.pboc.CardInfoData;
import com.centerm.smartpos.aidl.pboc.CardLoadLog;
import com.centerm.smartpos.aidl.pboc.CardTransLog;
import com.centerm.smartpos.aidl.pboc.EmvTransData;
import com.centerm.smartpos.aidl.pboc.PBOCListener;
import com.centerm.smartpos.aidl.pboc.ParcelableTrackData;
import com.centerm.smartpos.aidl.pinpad.AidlPinPad;
import com.centerm.smartpos.aidl.pinpad.MacInfo;
import com.centerm.smartpos.aidl.pinpad.PinInfo;
import com.centerm.smartpos.aidl.pinpad.PinPadBuilder;
import com.centerm.smartpos.aidl.pinpad.PinPadInputPinCallback;
import com.centerm.smartpos.aidl.printer.AidlPrinter;
import com.centerm.smartpos.aidl.qrscan.AidlQuickScanZbar;
import com.centerm.smartpos.aidl.qrscan.AidlScanCallback;
import com.centerm.smartpos.aidl.qrscan.CameraBeanZbar;
import com.centerm.smartpos.aidl.sys.AidlDeviceManager;
import com.centerm.smartpos.aidl.sys.AidlSystemSettingService;
import com.centerm.smartpos.constant.Constant;
import com.centerm.smartpos.constant.DeviceErrorCode;
import com.centerm.smartpos.util.CompactUtil;
import com.centerm.smartpos.util.EMVConstant;
import com.centerm.smartpos.util.EMVTAGS;
import com.centerm.smartpos.util.HexUtil;
import com.centerm.smartpos.util.TlvData;
import com.ibexlab.simple_pay_api.BuildConfig;
import com.ibexlab.simple_pay_api.device.DeviceManager;
import com.ibexlab.simple_pay_api.device.util.CentermPrintFormat;
import com.ibexlab.simple_pay_api.device.util.IResult;
import com.ibexlab.simple_pay_api.device.util.ISender;
import com.payneteasy.tlv.BerTag;
import com.payneteasy.tlv.BerTlv;
import com.payneteasy.tlv.BerTlvBuilder;
import com.payneteasy.tlv.BerTlvParser;
import com.payneteasy.tlv.BerTlvs;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class CentermDeviceManager {
    private static final String TAG = CentermDeviceManager.class.getSimpleName();
    private static final String FILE_DIR = "YoshopPOS";
    private static final String FILE_NAME = "key.ini";
    private static final String SERVICE_PACKAGE_NAME = "com.centerm.smartposservice";
    private static final String SERVICE_ACTION = "com.centerm.smartpos.service.MANAGER_SERVICE";
    private static final boolean ALLOW_INIT_KEYS = true; // TODO: false 이면 키 값이 앱에 포함되지 않음. 추후 false 로 변경
    private static final int READ_CARD_TIMEOUT = 60 * 1000; // 최대 60초
    //"DF1105D84000A800DF1205D84004F800DF13050010000000"        -- K9 Default
    //"DF11050000000000DF12050000000000DF13050000000000"        -- All Min
    //"DF1105FCF8FCF8E0DF1205FCF8FCF8E0DF1305FCF8FCF8E0"        -- All Max

    //Visa Paywave RID  "|A000000003|" 형태로 사용
    private static final String VISA_CONTACTLESS_RID = "|A000000003|";

    //Terminsl Option
    private static final String AID_SUPPORT_ONLINE_PIN = "DF180101";

    //9F3303E0F8C8  : Full CVM Support
    //9F3303E028C8  : SBT Only
    //9F3303E068C8  : SBT and Online pin
    private static final String AID_TERMINAL_CAPABILITIES = "9F3303E0F8C8";
    private static final String AID_TERMINAL_TYPE = "9F350121";
    private static final String AID_TERMINAL_FLOOR_LIMIT = "9F1B0400000000DF170100DF160100DF1503000000";

    private static final String AID_TERMINAL_TAC_DEFAULT = "DF1105C000000000"; //"DF11054000000000"; //"DF1105C000000000";
    //private static final String AID_TERMINAL_TAC_ONLINE  = "DF1205C000000000"; //"DF12054000000000";  //"DF1205C00000000";
    private static final String AID_TERMINAL_TAC_ONLINE = "DF1205C000C40000"; //Offline Pin 틀리면  Online go

    //기본값 DF13050000000000
    //Offline Declian 발생하도록 설정 : DF13050000008000
    private static final String AID_TERMINAL_TAC_DENIAL = "DF13050000000000";
    private static final String AID_DEFAULT_DDOL = "DF14039F3704";           //바꾸면 안됨

    //private static final String AID_ATTACH_STR1 = "DF1801019F3303E0F8C8";// + "DF1105C000000000" + "DF1205C000000000"; //"DF13050010000000";
    private static final String AID_ATTACH_STR1 =
            AID_SUPPORT_ONLINE_PIN
                    + AID_TERMINAL_TYPE
                    + AID_TERMINAL_CAPABILITIES
                    + AID_TERMINAL_FLOOR_LIMIT
                    + AID_TERMINAL_TAC_DEFAULT
                    + AID_TERMINAL_TAC_ONLINE
                    + AID_TERMINAL_TAC_DENIAL;
    //+ AID_DEFAULT_DDOL;
    // + "DF1105C000000000" + "DF1205C000000000"; //"DF13050010000000";

    private static final String AID_CURRNECY_KZT = "0398";
    private static final String AID_CURRENCY_RUB = "0643";
    private static final String AID_CURRENCY_USD = "0840";
    //private static final String AID_ATTACH_CURRENCY = "9F1A0206435F2A020643";

    private static final String[] TEST_CENTERM_AID = new String[]{
            //AID 셋팅시 통화코드 설정해야 함 9F1A020643 5F2A020643
            //AID 셋팅시 Terminal Capabilitie 설정 (확인중) : 9F3303E0F8C8
            "9F0606A00000002501",         // AMEX EMV Card 4

            "9F0607A0000000041010",       // MC PayPass EMV9
            "9F0607A0000000031010",       // EMV Card3,Card1,Card10 VSDC Inform Advice (SDT 성공)

            //"9F0608A000000333010101",     //UPI Card EMV6
            "9F0607A0000003330101",     //UPI Card EMV6  - KTC용 AID
            "9F0607A0000000651010",     //JCB A0000000651010
            "9F0607A0000001523010",       //다이너스 카드

            "9F0607A0000006581010",       //MIR	Russia	MIR Credit
            "9F0607A0000006582010",       //MIR	Russia	MIR DebitA000000003


            //기존 Sample AID 참조
            // EMV01, EMV03, EMV10
            //"9F0605A0000000039F22012FDF05083230313831323331DF060101DF070101DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF03146264D357658C10854FC1C4266AF9DB9DB45F3260",
            // EMV04
            //"9F0605A0000000259F22012FDF05083230303931323331DF060101DF070101DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF0314A2DD174368E726FFF49F19D7527BA85C0CDE00B7",
            // EMV09
            //"9F0605A0000000049F22012FDF05083230303931323331DF060101DF070101DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF031442EAB51FAD04CC20EF5A7E9FF8EA21F544D60DCC",
    };

    private static final String[] TEST_CENTERM_CAPK = new String[]{
            ////////////////////////////////////////////////////////////
            //Openway CAPK 생성시  Index 설정  9F220147
            ////////////////////////////////////////////////////////////
            //Amex EMV4
            "9F0605A0000000259F220147DF05083230303931323331DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF031498B21930A2FD791224999149FBF81875BE001956",
            //EMV8, EMV9
            "9F0605A0000000049F220147DF05083230303931323331DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF03146304B43BAF1342F914ABD4B55EE817CEF1FA557F",
            //EMV06, = 은련카드는 CAKK Algorithm이 있어야 로딩됨
            //정상 CAPK
            "9F0605A0000003339F220147DF05083230303931323331DF060101DF070101DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF031436C477A8B51F9FBA79E7E95B558106E9B5F293B9",
            //EMV11
            "9F0605A0000006589F220147DF05083230303931323331DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF03149CE3B5726ADED6E76F51AEBB6E175A5D69CD74B0",
            //EMV03, EMV01, EMV10
            "9F0605A0000000039F220147DF05083230303931323331DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF03149CE781693D808522CAC28A3A34C0BB3A742FA8F9",  //47
            //"9F0605A0000000039F22012FDF05083230313831323331DF060101DF070101DF028190F562B594C911C0310AEFB002BDFE01CC8C2F1351CAEDD12C5210F4C3507BC106E01BBF94362392F3A66496079CBC8EAD09D5D942B195CA12A8A1AABAEF1D5545AF1693484764DEB625100E15F630510F3E2FB9E00D81F86D4C6F099307182E30F67FBE9C3D91F557BA5AAA1ACFBB625ABFA0176D4CEF3DFE1892BA1EC49F57B5DB6C53147F1DC9FD844298E238A94FEBDF040103DF03146264D357658C10854FC1C4266AF9DB9DB45F3260",       //HEX Index

            ///////////////////////////////////////////////////////////
            //Real CAPK
            ///////////////////////////////////////////////////////////
            //AMEX 01
            //"9F0605A0000000259F220101DF060101DF070101DF0260AFAD7010F884E2824650F764D47D7951A16EED6DBB881F384DEDB6702E0FB55C0FBEF945A2017705E5286FA249A591E194BDCD74B21720B44CE986F144237A25F95789F38B47EA957F9ADB2372F6D5D41340A147EAC2AF324E8358AE1120EF3FDF040103DF0314ACFE734CF09A84C7BF025F0FFC6FA8CA25A22869",
            //AMEX 02
            //"9F0605A0000000259F220102DF060101DF070101DF0260AFAD7010F884E2824650F764D47D7951A16EED6DBB881F384DEDB6702E0FB55C0FBEF945A2017705E5286FA249A591E194BDCD74B21720B44CE986F144237A25F95789F38B47EA957F9ADB2372F6D5D41340A147EAC2AF324E8358AE1120EF3FDF040103DF03140B5FA6F213FBB36A5DE284410E5CA026C31297A8",
            //AMEX 03 - Live
            "9F0605A0000000259F220103DF05083230323831323331DF060101DF070101DF028180B0C2C6E2A6386933CD17C239496BF48C57E389164F2A96BFF133439AE8A77B20498BD4DC6959AB0C2D05D0723AF3668901937B674E5A2FA92DDD5E78EA9D75D79620173CC269B35F463B3D4AAFF2794F92E6C7A3FB95325D8AB95960C3066BE548087BCB6CE12688144A8B4A66228AE4659C634C99E36011584C095082A3A3E3DF040103DF03148708A3E3BBC1BB0BE73EBD8D19D4E5D20166BF6C",
            //AMEX 04 - Test
            "9F0605A0000000259F220104DF05083230323831323331DF060101DF070101DF0260D0F543F03F2517133EF2BA4A1104486758630DCFE3A883C77B4E4844E39A9BD6360D23E6644E1E071F196DDF2E4A68B4A3D93D14268D7240F6A14F0D714C17827D279D192E88931AF7300727AE9DA80A3F0E366AEBA61778171737989E1EE309DF040103DF0314FDD7139EC7E0C33167FD61AD3CADBD68D66E91C5",
            //AMEX 10 - Live
            "9F0605A0000000259F220110DF05083230323831323331DF060101DF070101DF0281F8CF98DFEDB3D3727965EE7797723355E0751C81D2D3DF4D18EBAB9FB9D49F38C8C4A826B99DC9DEA3F01043D4BF22AC3550E2962A59639B1332156422F788B9C16D40135EFD1BA94147750575E636B6EBC618734C91C1D1BF3EDC2A46A43901668E0FFC136774080E888044F6A1E65DC9AAA8928DACBEB0DB55EA3514686C6A732CEF55EE27CF877F110652694A0E3484C855D882AE191674E25C296205BBB599455176FDD7BBC549F27BA5FE35336F7E29E68D783973199436633C67EE5A680F05160ED12D1665EC83D1997F10FD05BBDBF9433E8F797AEE3E9F02A34228ACE927ABE62B8B9281AD08D3DF5C7379685045D7BA5FCDE58637DF040103DF0314C729CF2FD262394ABC4CC173506502446AA9B9FD",
            //AMEX 52
            "9F0605A0000000259F220152DF05083230323831323331DF060101DF070101DF028180B831414E0B4613922BD35B4B36802BC1E1E81C95A27C958F5382003DF646154CA92FC1CE02C3BE047A45E9B02A9089B4B90278237C965192A0FCC86BB49BC82AE6FDC2DE709006B86C7676EFDF597626FAD633A4F7DC48C445D37EB55FCB3B1ABB95BAAA826D5390E15FD14ED403FA2D0CB841C650609524EC555E3BC56CA957DF0403010001DF03149D93DA5E86FDF16318D268CA6AC57031EDFCA3CB",
            //AMEX 60
            "9F0605A0000000259F220160DF05083230323831323331DF060101DF070101DF0260D0F543F03F2517133EF2BA4A1104486758630DCFE3A883C77B4E4844E39A9BD6360D23E6644E1E071F196DDF2E4A68B4A3D93D14268D7240F6A14F0D714C17827D279D192E88931AF7300727AE9DA80A3F0E366AEBA61778171737989E1EE309DF040103DF0314C08E256F276ED814021B11CAF6EC3701EC7553A1",
            //AMEX 62 - Test
            "9F0605A0000000259F220162DF05083230323831323331DF060101DF070101DF0260BA29DE83090D8D5F4DFFCEB98918995A768F41D0183E1ACA3EF8D5ED9062853E4080E0D289A5CEDD4DD96B1FEA2C53428436CE15A2A1BFE69D46197D3F5A79BCF8F4858BFFA04EDB07FC5BE8560D9CE38F5C3CA3C742EDFDBAE3B5E6DDA45557DF040103DF0314CCC7303FF295A9F35BA61BD31E27EABD59658265",
            //AMEX 64
            "9F0605A0000000259F220164DF05083230323831323331DF060101DF070101DF028180B0DD551047DAFCD10D9A5E33CF47A9333E3B24EC57E8F066A72DED60E881A8AD42777C67ADDF0708042AB943601EE60248540B67E0637018EEB3911AE9C873DAD66CB40BC8F4DC77EB2595252B61C21518F79B706AAC29E7D3FD4D259DB72B6E6D446DD60386DB40F5FDB076D80374C993B4BB2D1DB977C3870897F9DFA454F5DF040103DF0314792B121D86D0F3A99582DB06974481F3B2E18454",
            //AMEX 65
            "9F0605A0000000259F220165DF05083230323831323331DF060101DF070101DF028190E53EB41F839DDFB474F272CD0CBE373D5468EB3F50F39C95BDF4D39FA82B98DABC9476B6EA350C0DCE1CD92075D8C44D1E57283190F96B3537D9E632C461815EBD2BAF36891DF6BFB1D30FA0B752C43DCA0257D35DFF4CCFC98F84198D5152EC61D7B5F74BD09383BD0E2AA42298FFB02F0D79ADB70D72243EE537F75536A8A8DF962582E9E6812F3A0BE02A4365400DDF040103DF0314894C5D08D4EA28BB79DC46CEAD998B877322F416",
            //AMEX 66
            "9F0605A0000000259F220166DF05083230323831323331DF060101DF070101DF028180BD1478877B9333612D257D9E3C9C23503E28336B723C71F47C25836670395360F53C106FD74DEEEA291259C001AFBE7B4A83654F6E2D9E8148E2CB1D9223AC5903DA18B433F8E3529227505DE84748F241F7BFCD2146E5E9A8C5D2A06D19097087A069F9AE3D610C7C8E1214481A4F27025A1A2EDB8A9CDAFA445690511DB805DF040103DF0314F367CB70F9C9B67B580F533819E302BAC0330090",
            //AMEX 67
            "9F0605A0000000259F220167DF050420221231DF060101DF070101DF0281B0C687ADCCF3D57D3360B174E471EDA693AA555DFDC6C8CD394C74BA25CCDF8EABFD1F1CEADFBE2280C9E81F7A058998DC22B7F22576FE84713D0BDD3D34CFCD12FCD0D26901BA74103D075C664DABCCAF57BF789494051C5EC303A2E1D784306D3DB3EB665CD360A558F40B7C05C919B2F0282FE1ED9BF6261AA814648FBC263B14214491DE426D242D65CD1FFF0FBE4D4DAFF5CFACB2ADC7131C9B147EE791956551076270696B75FD97373F1FD7804FDF040103DF031452A2907300C8445BF54B970C894691FEADF2D28E",
            //AMEX 68
            "9F0605A0000000259F220168DF05083230323831323331DF060101DF070101DF0281F8F4D198F2F0CF140E4D2D81B765EB4E24CED4C0834822769854D0E97E8066CBE465029B3F410E350F6296381A253BE71A4BBABBD516625DAE67D073D00113AAB9EA4DCECA29F3BB7A5D46C0D8B983E2482C2AD759735A5AB9AAAEFB31D3E718B8CA66C019ECA0A8BE312E243EB47A62300620BD51CF169A9194C17A42E51B34D83775A98E80B2D66F4F98084A448FE0507EA27C905AEE72B62A8A29438B6A4480FFF72F93280432A55FDD648AD93D82B9ECF01275C0914BAD8EB3AAF46B129F8749FEA425A2DCDD7E813A08FC0CA7841EDD49985CD8BC6D5D56F17AB9C67CEC50BA422440563ECCE21699E435C8682B6266393672C693D8B7DF040103DF0314415E5FE9EC966C835FBB3E6F766A9B1A4B8674C3",
            //AMEX 96
            "9F0605A0000000259F220196DF05083230323831323331DF060101DF070101DF028180BC9AA294B1FDD263176E3243D8F448BBFFCB6ABD02C31811289F5085A9262B8B1B7C6477EB58055D9EF32A83D1B72D4A1471ECA30CE76585C3FD05372B686F92B795B1640959201523230149118D52D2425BD11C863D9B2A7C4AD0A2BFDBCA67B2713B290F493CD5521E5DDF05EF1040FC238D0A851C8E3E3B2B1F0D5D9D4AEDDF040103DF0314E7433E5CFC6001151D8ECD252EBC6E61F7AB2217",
            //AMEX97
            "9F0605A0000000259F220197DF05083230323831323331DF060101DF070101DF028190E178FFE834B4B767AF3C9A511F973D8E8505C5FCB2D3768075AB7CC946A955789955879AAF737407151521996DFA43C58E6B130EB1D863B85DC9FFB4050947A2676AA6A061A4A7AE1EDB0E36A697E87E037517EB8923136875BA2CA1087CBA7EC7653E5E28A0C261A033AF27E3A67B64BBA26956307EC47E674E3F8B722B3AE0498DB16C7985310D9F3D117300D32B09DF040103DF0314EBDA522B631B3EB4F4CBFC0679C450139D2B69CD",
            //AMEX98
            "9F0605A0000000259F220198DF05083230323831323331DF060101DF070101DF0281B0D31A7094FB221CBA6660FB975AAFEA80DB7BB7EAFD7351E748827AB62D4AEECCFC1787FD47A04699A02DB00D7C382E80E804B35C59434C602389D691B9CCD51ED06BE67A276119C4C10E2E40FC4EDDF9DF39B9B0BDEE8D076E2A012E8A292AF8EFE18553470639C1A032252E0E5748B25A3F9BA4CFCEE073038B061837F2AC1B04C279640F5BD110A9DC665ED2FA6828BD5D0FE810A892DEE6B0E74CE8863BDE08FD5FD61A0F11FA0D14978D8CED7DD3DF040103DF0314D4DBA428CF11D45BAEB0A35CAEA8007AD8BA8D71",
            //AMEX 99
            //Incorract with ETF Lab
            //"9F0605A0000000259F220199DF060101DF070101DF0281F8E1740074229FA0D228A9623581D7A322903FB89BA7686712E601FA8AB24A9789186F15B70CCBBE7421B1CB110D45361688135FFD0DB15A3F516BB291D4A123EBF5A06FBF7E1EE6311B737DABB289570A7959D532B25F1DA6758C84DDCCADC049BC764C05391ABD2CADEFFA7E242D5DD06E56001F0E68151E3388074BD9330D6AFA57CBF33946F531E51E0D4902EE235C756A905FB733940E6EC897B4944A5EDC765705E2ACF76C78EAD78DD9B066DF0B2C88750B8AEE00C9B4D4091FA7338449DA92DBFC908FA0781C0128C492DB993C88BA8BB7CADFE238D477F2517E0E7E3D2B11796A0318CE2AD4DA1DB8E54AB0D94F109DB9CAEEFBEFDF040103DF031494790D020F4F692D59289F36451872078005B63B",
            //AMEX 0E - Live
            //"9F0605A0000000259F22010EDF050420131231DF060101DF070101DF028190AA94A8C6DAD24F9BA56A27C09B01020819568B81A026BE9FD0A3416CA9A71166ED5084ED91CED47DD457DB7E6CBCD53E560BC5DF48ABC380993B6D549F5196CFA77DFB20A0296188E969A2772E8C4141665F8BB2516BA2C7B5FC91F8DA04E8D512EB0F6411516FB86FC021CE7E969DA94D33937909A53A57F907C40C22009DA7532CB3BE509AE173B39AD6A01BA5BB85DF040103DF0314A7266ABAE64B42A3668851191D49856E17F8FBCD",
            "9F0605A0000000259F22010EDF05083230313331323331DF060101DF070101DF028190AA94A8C6DAD24F9BA56A27C09B01020819568B81A026BE9FD0A3416CA9A71166ED5084ED91CED47DD457DB7E6CBCD53E560BC5DF48ABC380993B6D549F5196CFA77DFB20A0296188E969A2772E8C4141665F8BB2516BA2C7B5FC91F8DA04E8D512EB0F6411516FB86FC021CE7E969DA94D33937909A53A57F907C40C22009DA7532CB3BE509AE173B39AD6A01BA5BB85DF040103DF0314A7266ABAE64B42A3668851191D49856E17F8FBCD",

            //AMEX0F - Live
            //"9F0605A0000000259F22010FDF050420221231DF060101DF070101DF0281B0C8D5AC27A5E1FB89978C7C6479AF993AB3800EB243996FBB2AE26B67B23AC482C4B746005A51AFA7D2D83E894F591A2357B30F85B85627FF15DA12290F70F05766552BA11AD34B7109FA49DE29DCB0109670875A17EA95549E92347B948AA1F045756DE56B707E3863E59A6CBE99C1272EF65FB66CBB4CFF070F36029DD76218B21242645B51CA752AF37E70BE1A84FF31079DC0048E928883EC4FADD497A719385C2BBBEBC5A66AA5E5655D18034EC5DF040103DF0314A73472B3AB557493A9BC2179CC8014053B12BAB4",
            "9F0605A0000000259F22010FDF05083230323231323331DF060101DF070101DF0281B0C8D5AC27A5E1FB89978C7C6479AF993AB3800EB243996FBB2AE26B67B23AC482C4B746005A51AFA7D2D83E894F591A2357B30F85B85627FF15DA12290F70F05766552BA11AD34B7109FA49DE29DCB0109670875A17EA95549E92347B948AA1F045756DE56B707E3863E59A6CBE99C1272EF65FB66CBB4CFF070F36029DD76218B21242645B51CA752AF37E70BE1A84FF31079DC0048E928883EC4FADD497A719385C2BBBEBC5A66AA5E5655D18034EC5DF040103DF0314A73472B3AB557493A9BC2179CC8014053B12BAB4",

            //AMEX A1 incorract with ETF Lab
            //"9F0605A0000000259F2201A1DF060101DF070101DF02819099D17396421EE3F919BA549D9554BE0D4F92CB8B53B4878ED60CC5B2DEEDC79B85C8BD6FD2F23C22E68B381AEEB74153AFB3C96E6C96AD018E73C2025D1EE77622A72BEE973C1AF7B908468D74FDB53DCE8380523E38C30D0A8A226529726824E209E668F49F43B0E8CD2FE527CE7CC41F33F434F95D6E2FE2F589372032F2D6504340F8C542D298B499A53D95AF4083DF040103DF0314FA130D2A6988E996002DB211EDB0FD373600D680",
            //AMEX C1 - Test
            "9F0605A0000000259F2201C7DF05083230323831323331DF060101DF070101DF028190CD237E34E0299DE48F1A2C94F478FE972896011E1CA6AB462B68FE0F6109C9A97C2DBEEA65932CDE0625138B9F162B92979DAAB019D3B5561D31EB2D4F09F12F927EA8F740CE0E87154965505E2272F69042B15D57CCC7F771919123978283B3CCE524D9715207BF5F5AD369102176F0F7A78A6DEB2BFF0EDCE165F3B14F14D0035B2756861FE03C43396ED002C894A3DF040103DF03146221E0C726BAC8F8AC25F8F93B811D1FFD4C131C",
            //AMEX C2 - Test
            "9F0605A0000000259F2201C2DF05083230323831323331DF060101DF070101DF0281B0B875002F38BA26D61167C5D440367604AD38DF2E93D8EE8DA0E8D9C0CF4CC5788D11DEA689E5F41D23A3DA3E0B1FA5875AE25620F5A6BCCEE098C1B35C691889D7D0EF670EB8312E7123FCC5DC7D2F0719CC80E1A93017F944D097330EDF945762FEE62B7B0BA0348228DBF38D4216E5A67A7EF74F5D3111C44AA31320F623CB3C53E60966D6920067C9E082B746117E48E4F00E110950CA54DA3E38E5453BD5544E3A6760E3A6A42766AD2284E0C9AFDF040103DF03148E748296359A7428F536ADDA8E2C037E2B697EF6",
            //AMEX C3 - Test
            "9F0605A0000000259F2201C3DF05083230323831323331DF060101DF070101DF0281F8B93182ABE343DFBF388C71C4D6747DCDEC60367FE63CFAA942D7D323E688D0832836548BF0EDFF1EDEEB882C75099FF81A93FA525C32425B36023EA02A8899B9BF7D7934E86F997891823006CEAA93091A73C1FDE18ABD4F87A22308640C064C8C027685F1B2DB7B741B67AB0DE05E870481C5F972508C17F57E4F833D63220F6EA2CFBB878728AA5887DE407D10C6B8F58D46779ECEC1E2155487D52C78A5C03897F2BB580E0A2BBDE8EA2E1C18F6AAF3EB3D04C3477DEAB88F150C8810FD1EF8EB0596866336FE2C1FBC6BEC22B4FE5D885647726DB59709A505F75C49E0D8D71BF51E4181212BE2142AB2A1E8C0D3B7136CD7B7708E4DDF040103DF031412F1790CB0273DC73C6E70784BC24C12E8DB71F6",
            //AMEX C7
            "9F0605A0000000259F2201C7DF05083230323831323331DF060101DF070101DF028190CD237E34E0299DE48F1A2C94F478FE972896011E1CA6AB462B68FE0F6109C9A97C2DBEEA65932CDE0625138B9F162B92979DAAB019D3B5561D31EB2D4F09F12F927EA8F740CE0E87154965505E2272F69042B15D57CCC7F771919123978283B3CCE524D9715207BF5F5AD369102176F0F7A78A6DEB2BFF0EDCE165F3B14F14D0035B2756861FE03C43396ED002C894A3DF040103DF03146221E0C726BAC8F8AC25F8F93B811D1FFD4C131C",
            //AMEX C8 - Test
            "9F0605A0000000259F2201C8DF05083230323831323331DF060101DF070101DF028190BF0CFCED708FB6B048E3014336EA24AA007D7967B8AA4E613D26D015C4FE7805D9DB131CED0D2A8ED504C3B5CCD48C33199E5A5BF644DA043B54DBF60276F05B1750FAB39098C7511D04BABC649482DDCF7CC42C8C435BAB8DD0EB1A620C31111D1AAAF9AF6571EEBD4CF5A08496D57E7ABDBB5180E0A42DA869AB95FB620EFF2641C3702AF3BE0B0C138EAEF202E21DDF040103DF031433BD7A059FAB094939B90A8F35845C9DC779BD50",
            //AMEX C9 - Test
            "9F0605A0000000259F2201C9DF05083230323831323331DF060101DF070101DF0281B0B362DB5733C15B8797B8ECEE55CB1A371F760E0BEDD3715BB270424FD4EA26062C38C3F4AAA3732A83D36EA8E9602F6683EECC6BAFF63DD2D49014BDE4D6D603CD744206B05B4BAD0C64C63AB3976B5C8CAAF8539549F5921C0B700D5B0F83C4E7E946068BAAAB5463544DB18C63801118F2182EFCC8A1E85E53C2A7AE839A5C6A3CABE73762B70D170AB64AFC6CA482944902611FB0061E09A67ACB77E493D998A0CCF93D81A4F6C0DC6B7DF22E62DBDF040103DF03148E8DFF443D78CD91DE88821D70C98F0638E51E49",
            //AMEX CA - Test
            "9F0605A0000000259F2201CADF05083230323831323331DF060101DF070101DF0281F8C23ECBD7119F479C2EE546C123A585D697A7D10B55C2D28BEF0D299C01DC65420A03FE5227ECDECB8025FBC86EEBC1935298C1753AB849936749719591758C315FA150400789BB14FADD6EAE2AD617DA38163199D1BAD5D3F8F6A7A20AEF420ADFE2404D30B219359C6A4952565CCCA6F11EC5BE564B49B0EA5BF5B3DC8C5C6401208D0029C3957A8C5922CBDE39D3A564C6DEBB6BD2AEF91FC27BB3D3892BEB9646DCE2E1EF8581EFFA712158AAEC541C0BBB4B3E279D7DA54E45A0ACC3570E712C9F7CDF985CFAFD382AE13A3B214A9E8E1E71AB1EA707895112ABC3A97D0FCB0AE2EE5C85492B6CFD54885CDD6337E895CC70FB3255E3DF040103DF03146BDA32B1AA171444C7E8F88075A74FBFE845765F",

            //Test CAPK
            //MASTER 00 - Test
            //"9F0605A0000000049F220100DF05083230323831323331DF060101DF070101DF0281A09C6BE5ADB10B4BE3DCE2099B4B210672B89656EBA091204F613ECC623BEDC9C6D77B660E8BAEEA7F7CE30F1B153879A4E36459343D1FE47ACDBD41FCD710030C2BA1D9461597982C6E1BDD08554B726F5EFF7913CE59E79E357295C321E26D0B8BE270A9442345C753E2AA2ACFC9D30850602FE6CAC00C6DDF6B8D9D9B4879B2826B042A07F0E5AE526A3D3C4D22C72B9EAA52EED8893866F866387AC05A1399DF040103DF0314EC0A59D35D19F031E9E8CBEC56DB80E22B1DE130",
            //MASTER_00 - Live
            "9F0605A0000000049F220100DF05083230303931323331DF060101DF070101DF02609E15214212F6308ACA78B80BD986AC287516846C8D548A9ED0A42E7D997C902C3E122D1B9DC30995F4E25C75DD7EE0A0CE293B8CC02B977278EF256D761194924764942FE714FA02E4D57F282BA3B2B62C9E38EF6517823F2CA831BDDF6D363DDF040103DF03148BB99ADDF7B560110955014505FB6B5F8308CE27",

            //MASTER_01 - Live
            "9F0605A0000000049F220101DF05083230303931323331DF060101DF070101DF0260D2010716C9FB5264D8C91A14F4F32F8981EE954F20087ED77CDC5868431728D3637C632CCF2718A4F5D92EA8AB166AB992D2DE24E9FBDC7CAB9729401E91C502D72B39F6866F5C098B1243B132AFEE65F5036E168323116338F8040834B98725DF040103DF0314EA950DD4234FEB7C900C0BE817F64DE66EEEF7C4",
            //MASTER_01 - TEST
            //"9F0605A0000000049F220101DF05083230323831323331DF060101DF070101DF028180C696034213D7D8546984579D1D0F0EA519CFF8DEFFC429354CF3A871A6F7183F1228DA5C7470C055387100CB935A712C4E2864DF5D64BA93FE7E63E71F25B1E5F5298575EBE1C63AA617706917911DC2A75AC28B251C7EF40F2365912490B939BCA2124A30A28F54402C34AECA331AB67E1E79B285DD5771B5D9FF79EA630B75DF040103DF03148C05A64127485B923C94B63D264AF0BF85CB45D9",
            //MASTER 02 - Live
            "9F0605A0000000049F220102DF05083230303931323331DF060101DF070101DF0270CF4264E1702D34CA897D1F9B66C5D63691EACC612C8F147116BB22D0C463495BD5BA70FB153848895220B8ADEEC3E7BAB31EA22C1DC9972FA027D54265BEBF0AE3A23A8A09187F21C856607B98BDA6FC908116816C502B3E58A145254EEFEE2A3335110224028B67809DCB8058E24895DF040103DF0314AF1CC1FD1C1BC9BCA07E78DA6CBA2163F169CBB7",
            //MASTER_02 - Test
            //"9F0605A0000000049F220102DF05083230323831323331DF060101DF070101DF0281C0A99A6D3E071889ED9E3A0C391C69B0B804FC160B2B4BDD570C92DD5A0F45F53E8621F7C96C40224266735E1EE1B3C06238AE35046320FD8E81F8CEB3F8B4C97B940930A3AC5E790086DAD41A6A4F5117BA1CE2438A51AC053EB002AED866D2C458FD73359021A12029A0C043045C11664FE0219EC63C10BF2155BB2784609A106421D45163799738C1C30909BB6C6FE52BBB76397B9740CE064A613FF8411185F08842A423EAD20EDFFBFF1CD6C3FE0C9821479199C26D8572CC8AFFF087A9C3DF040103DF031433408B96C814742AD73536C72F0926E4471E8E47",
            //MASTER 03 - Live
            "9F0605A0000000049F220103DF05083230303931323331DF060101DF070101DF028180C2490747FE17EB0584C88D47B1602704150ADC88C5B998BD59CE043EDEBF0FFEE3093AC7956AD3B6AD4554C6DE19A178D6DA295BE15D5220645E3C8131666FA4BE5B84FE131EA44B039307638B9E74A8C42564F892A64DF1CB15712B736E3374F1BBB6819371602D8970E97B900793C7C2A89A4A1649A59BE680574DD0B60145DF040103DF03145ADDF21D09278661141179CBEFF272EA384B13BB",
            //MASTER 04 - Live
            "9F0605A0000000049F220104DF05083230313731323331DF060101DF070101DF028190A6DA428387A502D7DDFB7A74D3F412BE762627197B25435B7A81716A700157DDD06F7CC99D6CA28C2470527E2C03616B9C59217357C2674F583B3BA5C7DCF2838692D023E3562420B4615C439CA97C44DC9A249CFCE7B3BFB22F68228C3AF13329AA4A613CF8DD853502373D62E49AB256D2BC17120E54AEDCED6D96A4287ACC5C04677D4A5A320DB8BEE2F775E5FEC5DF040103DF0314381A035DA58B482EE2AF75F4C3F2CA469BA4AA6C",
            //MASTER 05 - Live
            "9F0605A0000000049F220105DF05083230323431323331DF060101DF070101DF0281B0B8048ABC30C90D976336543E3FD7091C8FE4800DF820ED55E7E94813ED00555B573FECA3D84AF6131A651D66CFF4284FB13B635EDD0EE40176D8BF04B7FD1C7BACF9AC7327DFAA8AA72D10DB3B8E70B2DDD811CB4196525EA386ACC33C0D9D4575916469C4E4F53E8E1C912CC618CB22DDE7C3568E90022E6BBA770202E4522A2DD623D180E215BD1D1507FE3DC90CA310D27B3EFCCD8F83DE3052CAD1E48938C68D095AAC91B5F37E28BB49EC7ED597DF040103DF0314EBFA0D5D06D8CE702DA3EAE890701D45E274C845",
            //MASTER_05 - Test
            //"9F0605A0000000049F220105DF05083230323831323331DF060101DF070101DF028180A1F5E1C9BD8650BD43AB6EE56B891EF7459C0A24FA84F9127D1A6C79D4930F6DB1852E2510F18B61CD354DB83A356BD190B88AB8DF04284D02A4204A7B6CB7C5551977A9B36379CA3DE1A08E69F301C95CC1C20506959275F41723DD5D2925290579E5A95B0DF6323FC8E9273D6F849198C4996209166D9BFC973C361CC826E1DF040103DF031453D04903B496F59544A84309AF169251F2896874",
            //MASTER 06 - Live
            "9F0605A0000000049F220106DF05083230323831323331DF060101DF070101DF0281F8CB26FC830B43785B2BCE37C81ED334622F9622F4C89AAE641046B2353433883F307FB7C974162DA72F7A4EC75D9D657336865B8D3023D3D645667625C9A07A6B7A137CF0C64198AE38FC238006FB2603F41F4F3BB9DA1347270F2F5D8C606E420958C5F7D50A71DE30142F70DE468889B5E3A08695B938A50FC980393A9CBCE44AD2D64F630BB33AD3F5F5FD495D31F37818C1D94071342E07F1BEC2194F6035BA5DED3936500EB82DFDA6E8AFB655B1EF3D0D7EBF86B66DD9F29F6B1D324FE8B26CE38AB2013DD13F611E7A594D675C4432350EA244CC34F3873CBA06592987A1D7E852ADC22EF5A2EE28132031E48F74037E3B34AB747FDF040103DF0314F910A1504D5FFB793D94F3B500765E1ABCAD72D9",

            //MASTER 09
            "9F0605A0000000049F220109DF05083230323831323331DF060101DF070101DF0260967B6264436C96AA9305776A5919C70DA796340F9997A6C6EF7BEF1D4DBF9CB4289FB7990ABFF1F3AE692F12844B2452A50AE075FB327976A40E8028F279B1E3CCB623957D696FC1225CA2EC950E2D415E9AA931FF18B13168D661FBD06F0ABBDF040103DF03141D90595C2EF9FC6E71B0C721118333DF8A71FE21",
            //MASTER 22
            "9F0605A0000000049F220122DF05083230323831323331DF060101DF070101DF0260BBE43877CC28C0CE1E14BC14E8477317E218364531D155BB8AC5B63C0D6E284DD24259193899F9C04C30BAF167D57929451F67AEBD3BBD0D41444501847D8F02F2C2A2D14817D97AE2625DC163BF8B484C40FFB51749CEDDE9434FB2A0A41099DF040103DF0314008C39B1D119498268B07843349427AC6E98F807",
            //MASTER 52
            "9F0605A0000000049F220152DF05083230323831323331DF060101DF070101DF028180B831414E0B4613922BD35B4B36802BC1E1E81C95A27C958F5382003DF646154CA92FC1CE02C3BE047A45E9B02A9089B4B90278237C965192A0FCC86BB49BC82AE6FDC2DE709006B86C7676EFDF597626FAD633A4F7DC48C445D37EB55FCB3B1ABB95BAAA826D5390E15FD14ED403FA2D0CB841C650609524EC555E3BC56CA957DF0403010001DF0314DEB81EDB2626A4BB6AE23B77D19A77539D0E6716",
            //MASTER EF - Test
            "9F0605A0000000049F2201EFDF05083230323831323331DF060101DF070101DF0281F8A191CB87473F29349B5D60A88B3EAEE0973AA6F1A082F358D849FDDFF9C091F899EDA9792CAF09EF28F5D22404B88A2293EEBBC1949C43BEA4D60CFD879A1539544E09E0F09F60F065B2BF2A13ECC705F3D468B9D33AE77AD9D3F19CA40F23DCF5EB7C04DC8F69EBA565B1EBCB4686CD274785530FF6F6E9EE43AA43FDB02CE00DAEC15C7B8FD6A9B394BABA419D3F6DC85E16569BE8E76989688EFEA2DF22FF7D35C043338DEAA982A02B866DE5328519EBBCD6F03CDD686673847F84DB651AB86C28CF1462562C577B853564A290C8556D818531268D25CC98A4CC6A0BDFFFDA2DCCA3A94C998559E307FDDF915006D9A987B07DDAEB3BDF040103DF031421766EBB0EE122AFB65D7845B73DB46BAB65427A",
            //MASTER F0
            "9F0605A0000000049F2201F0DF05083230323831323331DF060101DF070101DF0281807563C51B5276AA6370AB8405522414645832B6BEF2A989C771475B2E8DC654DC8A5BFF9E28E31FF1A370A40DC3FFEB06BC85487D5F1CB61C2441FD71CBCD05D883F8DE413B243AFC9DCA768B061E35B884B5D21B6B016AA36BA12DABCFE49F8E528C893C34C7D4793977E4CC99AB09640D9C7AAB7EC5FF3F40E3D4D18DF7E3A7DF040103DF0314AE667445F8DE6F82C38800E5EBABA322F03F58F2",
            //MASTER F1 - Test
            "9F0605A0000000049F2201F1DF05083230323831323331DF060101DF070101DF0281B0A0DCF4BDE19C3546B4B6F0414D174DDE294AABBB828C5A834D73AAE27C99B0B053A90278007239B6459FF0BBCD7B4B9C6C50AC02CE91368DA1BD21AAEADBC65347337D89B68F5C99A09D05BE02DD1F8C5BA20E2F13FB2A27C41D3F85CAD5CF6668E75851EC66EDBF98851FD4E42C44C1D59F5984703B27D5B9F21B8FA0D93279FBBF69E090642909C9EA27F898959541AA6757F5F624104F6E1D3A9532F2A6E51515AEAD1B43B3D7835088A2FAFA7BE7DF040103DF0314D8E68DA167AB5A85D8C3D55ECB9B0517A1A5B4BB",
            //Master F3 - Test
            "9F0605A0000000049F2201F3DF05083230323831323331DF060101DF070101DF02819098F0C770F23864C2E766DF02D1E833DFF4FFE92D696E1642F0A88C5694C6479D16DB1537BFE29E4FDC6E6E8AFD1B0EB7EA0124723C333179BF19E93F10658B2F776E829E87DAEDA9C94A8B3382199A350C077977C97AFF08FD11310AC950A72C3CA5002EF513FCCC286E646E3C5387535D509514B3B326E1234F9CB48C36DDD44B416D23654034A66F403BA511C5EFA3DF040103DF0314A69AC7603DAF566E972DEDC2CB433E07E8B01A9A",
            //MASTER F4
            "9F0605A0000000049F2201F4DF05083230323831323331DF060101DF070101DF0281B09E2F74BF4AB521019735BFC7E4CBC56B6F64AFF1ED7B79998EE5B3DFFE23DFC8E2DD0025575AF94DE814264528AF6F8005A538B3D6AE881B350F89595588E51F7423E711109DEC169FDD560602D80EF46E582C8C546C8930394BD534412A88CC9FF4DFC08AE716A595EF1AF7C32EDFCF996433EB3C36BCE093E44E0BDE228E0299A0E358BF28308DB4739815DD09F1E89654CC7CC193E2AC17C4DA335D904B8EC06ACFBDE083F76933C969672E9AFEA3DF040103DF0314BF6B5B9C47134E494571732A4903C935874682B9",
            //MASTER F5 - Test
            "9F0605A0000000049F2201F5DF05083230323831323331DF060101DF070101DF0281F8A6E6FB72179506F860CCCA8C27F99CECD94C7D4F3191D303BBEE37481C7AA15F233BA755E9E4376345A9A67E7994BDC1C680BB3522D8C93EB0CCC91AD31AD450DA30D337662D19AC03E2B4EF5F6EC18282D491E19767D7B24542DFDEFF6F62185503532069BBB369E3BB9FB19AC6F1C30B97D249EEE764E0BAC97F25C873D973953E5153A42064BBFABFD06A4BB486860BF6637406C9FC36813A4A75F75C31CCA9F69F8DE59ADECEF6BDE7E07800FCBE035D3176AF8473E23E9AA3DFEE221196D1148302677C720CFE2544A03DB553E7F1B8427BA1CC72B0F29B12DFEF4C081D076D353E71880AADFF386352AF0AB7B28ED49E1E672D11F9DF0403010001DF0314C2239804C8098170BE52D6D5D4159E81CE8466BF",
            //MASTER F6 - Test
            "9F0605A0000000049F2201F6DF05083230323831323331DF060101DF070101DF0281E0A25A6BD783A5EF6B8FB6F83055C260F5F99EA16678F3B9053E0F6498E82C3F5D1E8C38F13588017E2B12B3D8FF6F50167F46442910729E9E4D1B3739E5067C0AC7A1F4487E35F675BC16E233315165CB142BFDB25E301A632A54A3371EBAB6572DEEBAF370F337F057EE73B4AE46D1A8BC4DA853EC3CC12C8CBC2DA18322D68530C70B22BDAC351DD36068AE321E11ABF264F4D3569BB71214545005558DE26083C735DB776368172FE8C2F5C85E8B5B890CC682911D2DE71FA626B8817FCCC08922B703869F3BAEAC1459D77CD85376BC36182F4238314D6C4212FBDD7F23D3DF040103DF0314502909ED545E3C8DBD00EA582D0617FEE9F6F684",
            //MASTER F7 - Test
            "9F0605A0000000049F2201F7DF05083230323831323331DF060101DF070101DF02818094EA62F6D58320E354C022ADDCF0559D8CF206CD92E869564905CE21D720F971B7AEA374830EBE1757115A85E088D41C6B77CF5EC821F30B1D890417BF2FA31E5908DED5FA677F8C7B184AD09028FDDE96B6A6109850AA800175EABCDBBB684A96C2EB6379DFEA08D32FE2331FE103233AD58DCDB1E6E077CB9F24EAEC5C25AFDF0403010001DF0314EEB0DD9B2477BEE3209A914CDBA94C1C4A9BDED9",
            //MASTER F8 - Test
            "9F0605A0000000049F2201F8DF05083230323831323331DF060101DF070101DF028180A1F5E1C9BD8650BD43AB6EE56B891EF7459C0A24FA84F9127D1A6C79D4930F6DB1852E2510F18B61CD354DB83A356BD190B88AB8DF04284D02A4204A7B6CB7C5551977A9B36379CA3DE1A08E69F301C95CC1C20506959275F41723DD5D2925290579E5A95B0DF6323FC8E9273D6F849198C4996209166D9BFC973C361CC826E1DF040103DF0314F06ECC6D2AAEBF259B7E755A38D9A9B24E2FF3DD",
            //MASTER F9 - Test
            "9F0605A0000000049F2201F9DF05083230323831323331DF060101DF070101DF0281C0A99A6D3E071889ED9E3A0C391C69B0B804FC160B2B4BDD570C92DD5A0F45F53E8621F7C96C40224266735E1EE1B3C06238AE35046320FD8E81F8CEB3F8B4C97B940930A3AC5E790086DAD41A6A4F5117BA1CE2438A51AC053EB002AED866D2C458FD73359021A12029A0C043045C11664FE0219EC63C10BF2155BB2784609A106421D45163799738C1C30909BB6C6FE52BBB76397B9740CE064A613FF8411185F08842A423EAD20EDFFBFF1CD6C3FE0C9821479199C26D8572CC8AFFF087A9C3DF040103DF0314336712DCC28554809C6AA9B02358DE6F755164DB",

            //MASTER FA
            "9F0605A0000000049F2201FADF05083230323831323331DF060101DF070101DF0281A09C6BE5ADB10B4BE3DCE2099B4B210672B89656EBA091204F613ECC623BEDC9C6D77B660E8BAEEA7F7CE30F1B153879A4E36459343D1FE47ACDBD41FCD710030C2BA1D9461597982C6E1BDD08554B726F5EFF7913CE59E79E357295C321E26D0B8BE270A9442345C753E2AA2ACFC9D30850602FE6CAC00C6DDF6B8D9D9B4879B2826B042A07F0E5AE526A3D3C4D22C72B9EAA52EED8893866F866387AC05A1399DF040103DF03140ABCADAD2C7558CA9C7081AE55DDDC714F8D45F8",
            //MASTER FB - Incorract Hash
            //"9F0605A0000000049F2201FBDF050420191231DF060101DF070101DF028180A9548DFB398B48123FAF41E6CFA4AE1E2352B518AB4BCEFECDB0B3EDEC090287D88B12259F361C1CC088E5F066494417E8EE8BBF8991E2B32FF16F994697842B3D6CB37A2BB5742A440B6356C62AA33DB3C455E59EDDF7864701D03A5B83EE9E9BD83AB93302AC2DFE63E66120B051CF081F56326A71303D952BB336FF12610DDF040102DF0314A54CB4AEC9BD9D4F579756A2B9E09CDB49E477E8",
            //MASTER FC - Incorract Hash
            //"9F0605A0000000049F2201FCDF05083230323831323331DF060101DF070101DF0270B37BFD2A9674AD6221C1A001081C62653DC280B0A9BD052C677C913CE7A0D902E77B12F4D4D79037B1E9B923A8BB3FAC3C612045BB3914F8DF41E9A1B61BFA5B41705A691D09CE6F530FE48B30240D98F4E692FFD6AADB87243BA8597AB237586ECF258F4148751BE5DA5A3BE6CC34BDDF040102DF031474755521F60CACF9D20E759957D241E12BE0C957",
            //MASTER FD - Incorract Hash
            //"9F0605A0000000049F2201FDDF05083230323831323331DF060101DF070101DF0260B3572BA49AE4C7B7A0019E5189E142CFCDED9498DDB5F0470567AB0BA713B8DA226424622955B54B937ABFEFAAD97919E377621E22196ABC1419D5ADC123484209EA7CB7029E66A0D54C5B45C8AD615AEDB6AE9E0A2F75310EA8961287241245DF040102DF0314623189465E3148DD2AC28E1934915803AD9A60E4",
            //MASTER FE - Test
            "9F0605A0000000049F2201FEDF05083230323831323331DF060101DF070101DF028180A653EAC1C0F786C8724F737F172997D63D1C3251C44402049B865BAE877D0F398CBFBE8A6035E24AFA086BEFDE9351E54B95708EE672F0968BCD50DCE40F783322B2ABA04EF137EF18ABF03C7DBC5813AEAEF3AA7797BA15DF7D5BA1CBAF7FD520B5A482D8D3FEE105077871113E23A49AF3926554A70FE10ED728CF793B62A1DF040103DF03149A295B05FB390EF7923F57618A9FDA2941FC34E0",
            //MASTER FF
            "9F0605A0000000049F2201FFDF05083230323831323331DF060101DF070101DF0270B855CC64313AF99C453D181642EE7DD21A67D0FF50C61FE213BCDC18AFBCD07722EFDD2594EFDC227DA3DA23ADCC90E3FA907453ACC954C47323BEDCF8D4862C457D25F47B16D7C3502BE081913E5B0482D838484065DA5F6659E00A9E5D570ADA1EC6AF8C57960075119581FC81468DDF040103DF0314B4E769CECF7AAC4783F305E0B110602A07A6355B",

            //Real CAPK
            //VISA 01 - Live
            "9F0605A0000000039F220101DF05083230303931323331DF060101DF070101DF028180C696034213D7D8546984579D1D0F0EA519CFF8DEFFC429354CF3A871A6F7183F1228DA5C7470C055387100CB935A712C4E2864DF5D64BA93FE7E63E71F25B1E5F5298575EBE1C63AA617706917911DC2A75AC28B251C7EF40F2365912490B939BCA2124A30A28F54402C34AECA331AB67E1E79B285DD5771B5D9FF79EA630B75DF040103DF0314D34A6A776011C7E7CE3AEC5F03AD2F8CFC5503CC",
            //VISA 03
            "9F0605A0000000039F220103DF050420191231DF060101DF070101DF0270B3E5E667506C47CAAFB12A2633819350846697DD65A796E5CE77C57C626A66F70BB630911612AD2832909B8062291BECA46CD33B66A6F9C9D48CED8B4FC8561C8A1D8FB15862C9EB60178DEA2BE1F82236FFCFF4F3843C272179DCDD384D541053DA6A6A0D3CE48FDC2DC4E3E0EEE15FDF040103DF0314FE70AB3B4D5A1B9924228ADF8027C758483A8B7E",
            //VISA 05
            "9F0605A0000000039F220105DF050420291231DF060101DF070101DF0260D0135CE8A4436C7F9D5CC66547E30EA402F98105B71722E24BC08DCC80AB7E71EC23B8CE6A1DC6AC2A8CF55543D74A8AE7B388F9B174B7F0D756C22CBB5974F9016A56B601CCA64C71F04B78E86C501B193A5556D5389ECE4DEA258AB97F52A3DF040103DF031486DF041E7995023552A79E2623E49180C0CD957A",
            //VISA 06
            "9F0605A0000000039F220106DF050420291231DF060101DF070101DF0260F934FC032BE59B609A9A649E04446F1B365D1D23A1E6574E490170527EDF32F398326159B39B63D07E95E6276D7FCBB786925182BC0667FBD8F6566B361CA41A38DDF227091B87FA4F47BAC780AC47E15A6A0FB65393EB3473E8D193A07EB579DF040103DF0314A0DF5DAA385AE3E0E21BFD34D9D8A30506B19B12",
            //VISA 07 - Live
            "9F0605A0000000039F220107DF05083230313731323331DF060101DF070101DF028190A89F25A56FA6DA258C8CA8B40427D927B4A1EB4D7EA326BBB12F97DED70AE5E4480FC9C5E8A972177110A1CC318D06D2F8F5C4844AC5FA79A4DC470BB11ED635699C17081B90F1B984F12E92C1C529276D8AF8EC7F28492097D8CD5BECEA16FE4088F6CFAB4A1B42328A1B996F9278B0B7E3311CA5EF856C2F888474B83612A82E4E00D0CD4069A6783140433D50725FDF040103DF0314B4BC56CC4E88324932CBC643D6898F6FE593B172",
            //VISA 08 - Live
            "9F0605A0000000039F220108DF05083230323431323331DF060101DF070101DF0281B0D9FD6ED75D51D0E30664BD157023EAA1FFA871E4DA65672B863D255E81E137A51DE4F72BCC9E44ACE12127F87E263D3AF9DD9CF35CA4A7B01E907000BA85D24954C2FCA3074825DDD4C0C8F186CB020F683E02F2DEAD3969133F06F7845166ACEB57CA0FC2603445469811D293BFEFBAFAB57631B3DD91E796BF850A25012F1AE38F05AA5C4D6D03B1DC2E568612785938BBC9B3CD3A910C1DA55A5A9218ACE0F7A21287752682F15832A678D6E1ED0BDF040103DF031420D213126955DE205ADC2FD2822BD22DE21CF9A8",
            //VISA 09 - Live
            "9F0605A0000000039F220109DF05083230323831323331DF060101DF070101DF0281F89D912248DE0A4E39C1A7DDE3F6D2588992C1A4095AFBD1824D1BA74847F2BC4926D2EFD904B4B54954CD189A54C5D1179654F8F9B0D2AB5F0357EB642FEDA95D3912C6576945FAB897E7062CAA44A4AA06B8FE6E3DBA18AF6AE3738E30429EE9BE03427C9D64F695FA8CAB4BFE376853EA34AD1D76BFCAD15908C077FFE6DC5521ECEF5D278A96E26F57359FFAEDA19434B937F1AD999DC5C41EB11935B44C18100E857F431A4A5A6BB65114F174C2D7B59FDF237D6BB1DD0916E644D709DED56481477C75D95CDD68254615F7740EC07F330AC5D67BCD75BF23D28A140826C026DBDE971A37CD3EF9B8DF644AC385010501EFC6509D7A41DF040103DF03141FF80A40173F52D7D27E0F26A146A1C8CCB29046",
            //VISA 10
            "9F0605A0000000039F220110DF050420281231DF060101DF070101DF0281809F2701C0909CCBD8C3ED3E071C69F776160022FF3299807ED7A035ED5752770E232D56CC3BE159BD8F0CA8B59435688922F406F55C75639457BBABEFE9A86B2269EF223E34B91AA6DF2CCAD03B4AD4B443D61575CA960845E6C69040101E231D9EF811AD99B0715065A0E661449C41B4B023B7716D1E4AFF1C90704E55AE1225DF040103DF0314833B1947778036B6D759FCE3F618DDEB2749372C",
            //VISA 20
            "9F0605A0000000039F220120DF050420281231DF060101DF070101DF028180998D2AD946A60FC597D93807DB54B2B0A550871E43F1779F073AF08D9B04ABD17C8A7DAA3E66EE443F30F92648FC53DA57A78364B062FEDB50F7235B937E16E5F6D9E6BA8F106FB325ECA25125111CE04B43098CDEA8A41426FC6D94F8A47619EDB12789581808692CFBA1F38E8008CC5E02066A1889D52F77B9A121E6597F39DF040103DF03147AC3D80EF01E9A998F0A77181E64B36747DC51EB",
            //VISA 50
            "9F0605A0000000039F220150DF05083230323831323331DF060101DF070101DF028180D11197590057B84196C2F4D11A8F3C05408F422A35D702F90106EA5B019BB28AE607AA9CDEBCD0D81A38D48C7EBB0062D287369EC0C42124246AC30D80CD602AB7238D51084DED4698162C59D25EAC1E66255B4DB2352526EF0982C3B8AD3D1CCE85B01DB5788E75E09F44BE7361366DEF9D1E1317B05E5D0FF5290F88A0DB47DF0403010001DF0314B769775668CACB5D22A647D1D993141EDAB7237B",
            //VISA 51
            "9F0605A0000000039F220151DF05083230323831323331DF060101DF070101DF0260BBE43877CC28C0CE1E14BC14E8477317E218364531D155BB8AC5B63C0D6E284DD24259193899F9C04C30BAF167D57929451F67AEBD3BBD0D41444501847D8F02F2C2A2D14817D97AE2625DC163BF8B484C40FFB51749CEDDE9434FB2A0A41099DF040103DF0314D3D90B35BA8C48731171EAC407D89005ACF6F9DA",
            //VISA 52
            "9F0605A0000000039F220152DF05083230323831323331DF060101DF070101DF028180B831414E0B4613922BD35B4B36802BC1E1E81C95A27C958F5382003DF646154CA92FC1CE02C3BE047A45E9B02A9089B4B90278237C965192A0FCC86BB49BC82AE6FDC2DE709006B86C7676EFDF597626FAD633A4F7DC48C445D37EB55FCB3B1ABB95BAAA826D5390E15FD14ED403FA2D0CB841C650609524EC555E3BC56CA957DF0403010001DF031473A7CA6BA7DB3C37B78E86952BC4EC7754925D54",
            //VISA 53 = Hash Mismatch
            //VISA 58 = Hash Mismatch
            //VISA 89
            "9F0605A0000000039F220189DF05083230323831323331DF060101DF070101DF0281C0E5E195705CE61A0672B8367E7A51713927A04289EA308328FAD28071ECEAE889B3C4F29AC3BDE46772B00D42FD05F27228820F2693990F81B0F6928E240D957EC4484354CD5E5CA9092B444741A0394D3476651232474A9B87A961DA8DD96D90F036E9B3C52FB09766BDA4D6BC3BDADBC89122B74068F8FA04026C5FA8EF398BC3AB3992A87F6A785CC779BA99F170956623D67A18EB8324263D626BE85BFF77B8B981C0A3F7849C4F3D8E20542955D19128198547B47AE34DF67F28BE433F33DF040103DF03147170850B97F83952045CF9CA8B7612DFEB69E9EF",
            //VISA 90
            "9F0605A0000000039F220190DF05083230323831323331DF060101DF070101DF0240C26B3CB3833E42D8270DC10C8999B2DA18106838650DA0DBF154EFD51100AD144741B2A87D6881F8630E3348DEA3F78038E9B21A697EB2A6716D32CBF26086F1DF040103DF0314B3AE2BC3CAFC05EEEFAA46A2A47ED51DE679F823",
            //VISA 92 - Test
            "9F0605A0000000039F220192DF05083230323831323331DF060101DF070101DF0281B0996AF56F569187D09293C14810450ED8EE3357397B18A2458EFAA92DA3B6DF6514EC060195318FD43BE9B8F0CC669E3F844057CBDDF8BDA191BB64473BC8DC9A730DB8F6B4EDE3924186FFD9B8C7735789C23A36BA0B8AF65372EB57EA5D89E7D14E9C7B6B557460F10885DA16AC923F15AF3758F0F03EBD3C5C2C949CBA306DB44E6A2C076C5F67E281D7EF56785DC4D75945E491F01918800A9E2DC66F60080566CE0DAF8D17EAD46AD8E30A247C9FDF040103DF0314429C954A3859CEF91295F663C963E582ED6EB253",
            //VISA 94 - Test
            "9F0605A0000000039F220194DF05083230323831323331DF060101DF070101DF0281F8ACD2B12302EE644F3F835ABD1FC7A6F62CCE48FFEC622AA8EF062BEF6FB8BA8BC68BBF6AB5870EED579BC3973E121303D34841A796D6DCBC41DBF9E52C4609795C0CCF7EE86FA1D5CB041071ED2C51D2202F63F1156C58A92D38BC60BDF424E1776E2BC9648078A03B36FB554375FC53D57C73F5160EA59F3AFC5398EC7B67758D65C9BFF7828B6B82D4BE124A416AB7301914311EA462C19F771F31B3B57336000DFF732D3B83DE07052D730354D297BEC72871DCCF0E193F171ABA27EE464C6A97690943D59BDABB2A27EB71CEEBDAFA1176046478FD62FEC452D5CA393296530AA3F41927ADFE434A2DF2AE3054F8840657A26E0FC617DF040103DF0314C4A3C43CCF87327D136B804160E47D43B60E6E0F",
            //VISA 95 - Test
            "9F0605A0000000039F220195DF05083230323831323331DF060101DF070101DF028190BE9E1FA5E9A803852999C4AB432DB28600DCD9DAB76DFAAA47355A0FE37B1508AC6BF38860D3C6C2E5B12A3CAAF2A7005A7241EBAA7771112C74CF9A0634652FBCA0E5980C54A64761EA101A114E0F0B5572ADD57D010B7C9C887E104CA4EE1272DA66D997B9A90B5A6D624AB6C57E73C8F919000EB5F684898EF8C3DBEFB330C62660BED88EA78E909AFF05F6DA627BDF040103DF0314EE1511CEC71020A9B90443B37B1D5F6E703030F6",
            //VISA 96
            "9F0605A0000000039F220196DF05083230323831323331DF060101DF070101DF028180B74586D19A207BE6627C5B0AAFBC44A2ECF5A2942D3A26CE19C4FFAEEE920521868922E893E7838225A3947A2614796FB2C0628CE8C11E3825A56D3B1BBAEF783A5C6A81F36F8625395126FA983C5216D3166D48ACDE8A431212FF763A7F79D9EDB7FED76B485DE45BEB829A3D4730848A366D3324C3027032FF8D16A1E44D8DDF040103DF03147616E9AC8BE014AF88CA11A8FB17967B7394030E",
            //VISA 97
            "9F0605A0000000039F220197DF05083230323831323331DF060101DF070101DF0260AF0754EAED977043AB6F41D6312AB1E22A6809175BEB28E70D5F99B2DF18CAE73519341BBBD327D0B8BE9D4D0E15F07D36EA3E3A05C892F5B19A3E9D3413B0D97E7AD10A5F5DE8E38860C0AD004B1E06F4040C295ACB457A788551B6127C0B29DF040103DF03148001CA76C1203955E2C62841CD6F201087E564BF",
            //VISA 98
            "9F0605A0000000039F220198DF05083230323831323331DF060101DF070101DF0270CA026E52A695E72BD30AF928196EEDC9FAF4A619F2492E3FB31169789C276FFBB7D43116647BA9E0D106A3542E3965292CF77823DD34CA8EEC7DE367E08070895077C7EFAD939924CB187067DBF92CB1E785917BD38BACE0C194CA12DF0CE5B7A50275AC61BE7C3B436887CA98C9FD39DF040103DF0314E7AC9AA8EED1B5FF1BD532CF1489A3E5557572C1",
            //VISA 99 - Test
            "9F0605A0000000039F220199DF05083230323831323331DF060101DF070101DF028180AB79FCC9520896967E776E64444E5DCDD6E13611874F3985722520425295EEA4BD0C2781DE7F31CD3D041F565F747306EED62954B17EDABA3A6C5B85A1DE1BEB9A34141AF38FCF8279C9DEA0D5A6710D08DB4124F041945587E20359BAB47B7575AD94262D4B25F264AF33DEDCF28E09615E937DE32EDC03C54445FE7E382777DF040103DF03144ABFFD6B1C51212D05552E431C5B17007D2F5E6D",
            //VISA F3
            "9F0605A0000000039F2201F3DF05083230323831323331DF060101DF070101DF02819098F0C770F23864C2E766DF02D1E833DFF4FFE92D696E1642F0A88C5694C6479D16DB1537BFE29E4FDC6E6E8AFD1B0EB7EA0124723C333179BF19E93F10658B2F776E829E87DAEDA9C94A8B3382199A350C077977C97AFF08FD11310AC950A72C3CA5002EF513FCCC286E646E3C5387535D509514B3B326E1234F9CB48C36DDD44B416D23654034A66F403BA511C5EFA3DF040103DF0314128EB33128E63E38C9A83A2B1A9349E178F82196",

            //Union Pay
            //UPI 01 - LIVE
            "9F0605A0000003339F220101DF05083230303931323331DF060101DF070101DF028180BBE9066D2517511D239C7BFA77884144AE20C7372F515147E8CE6537C54C0A6A4D45F8CA4D290870CDA59F1344EF71D17D3F35D92F3F06778D0D511EC2A7DC4FFEADF4FB1253CE37A7B2B5A3741227BEF72524DA7A2B7B1CB426BEE27BC513B0CB11AB99BC1BC61DF5AC6CC4D831D0848788CD74F6D543AD37C5A2B4C5D5A93BDF040103DF0314E881E390675D44C2DD81234DCE29C3F5AB2297A0",
            //UPI 02 - LIVE
            "9F0605A0000003339F220102DF05083230323131323331DF060101DF070101DF028190A3767ABD1B6AA69D7F3FBF28C092DE9ED1E658BA5F0909AF7A1CCD907373B7210FDEB16287BA8E78E1529F443976FD27F991EC67D95E5F4E96B127CAB2396A94D6E45CDA44CA4C4867570D6B07542F8D4BF9FF97975DB9891515E66F525D2B3CBEB6D662BFB6C3F338E93B02142BFC44173A3764C56AADD202075B26DC2F9F7D7AE74BD7D00FD05EE430032663D27A57DF040103DF031403BB335A8549A03B87AB089D006F60852E4B8060",
            //UPI 03 - LIVE
            "9F0605A0000003339F220103DF05083230323431323331DF060101DF070101DF0281B0B0627DEE87864F9C18C13B9A1F025448BF13C58380C91F4CEBA9F9BCB214FF8414E9B59D6ABA10F941C7331768F47B2127907D857FA39AAF8CE02045DD01619D689EE731C551159BE7EB2D51A372FF56B556E5CB2FDE36E23073A44CA215D6C26CA68847B388E39520E0026E62294B557D6470440CA0AEFC9438C923AEC9B2098D6D3A1AF5E8B1DE36F4B53040109D89B77CAFAF70C26C601ABDF59EEC0FDC8A99089140CD2E817E335175B03B7AA33DDF040103DF031487F0CD7C0E86F38F89A66F8C47071A8B88586F26",
            //UPI 04 - LIVE
            "9F0605A0000003339F220104DF05083230323431323331DF060101DF070101DF0281F8BC853E6B5365E89E7EE9317C94B02D0ABB0DBD91C05A224A2554AA29ED9FCB9D86EB9CCBB322A57811F86188AAC7351C72BD9EF196C5A01ACEF7A4EB0D2AD63D9E6AC2E7836547CB1595C68BCBAFD0F6728760F3A7CA7B97301B7E0220184EFC4F653008D93CE098C0D93B45201096D1ADFF4CF1F9FC02AF759DA27CD6DFD6D789B099F16F378B6100334E63F3D35F3251A5EC78693731F5233519CDB380F5AB8C0F02728E91D469ABD0EAE0D93B1CC66CE127B29C7D77441A49D09FCA5D6D9762FC74C31BB506C8BAE3C79AD6C2578775B95956B5370D1D0519E37906B384736233251E8F09AD79DFBE2C6ABFADAC8E4D8624318C27DAF1DF040103DF0314F527081CF371DD7E1FD4FA414A665036E0F5E6E5",
            //UPI 08
            "9F0605A0000003339F220108DF05083230333031323331DF060101DF070101DF028190B61645EDFD5498FB246444037A0FA18C0F101EBD8EFA54573CE6E6A7FBF63ED21D66340852B0211CF5EEF6A1CD989F66AF21A8EB19DBD8DBC3706D135363A0D683D046304F5A836BC1BC632821AFE7A2F75DA3C50AC74C545A754562204137169663CFCC0B06E67E2109EBA41BC67FF20CC8AC80D7B6EE1A95465B3B2657533EA56D92D539E5064360EA4850FED2D1BFDF040103DF0314EE23B616C95C02652AD18860E48787C079E8E85A",
            //UPI 09
            "9F0605A0000003339F220109DF05083230333031323331DF060101DF070101DF0281B0EB374DFC5A96B71D2863875EDA2EAFB96B1B439D3ECE0B1826A2672EEEFA7990286776F8BD989A15141A75C384DFC14FEF9243AAB32707659BE9E4797A247C2F0B6D99372F384AF62FE23BC54BCDC57A9ACD1D5585C303F201EF4E8B806AFB809DB1A3DB1CD112AC884F164A67B99C7D6E5A8A6DF1D3CAE6D7ED3D5BE725B2DE4ADE23FA679BF4EB15A93D8A6E29C7FFA1A70DE2E54F593D908A3BF9EBBD760BBFDC8DB8B54497E6C5BE0E4A4DAC29E5DF040103DF0314A075306EAB0045BAF72CDD33B3B678779DE1F527",
            //UPI 80
            "9F0605A0000003339F220180DF05083230323831323331DF060101DF070101DF0281809DD730669F27892944A68C0C62344C0E8EC57C2AA78004B014C26A0B0F3B517A0B60D355DFBC8929BBC59CEBCD0CCA13CDAA0C94E91C84A26E7DBE6B58595C4EFF2D717CB9EB965C15D287AF60AC28D06BC51282BC4A518B0EA3ABA9343F1778545FFB49EE840BBCEA457DBAABBFD755BA0F943A08A59CFFB6066B4084767599DF0403010001DF0314A35663495B5702D2ADE19104ADB8EE07F97E8B2A",
            //UPI 83
            "9F0605A0000003339F220183DF05083230323831323331DF060101DF070101DF028190E46C9D054471D24A3DAEEA13875ECFB92C34D309106092E6AF57BD612C18E4E2BB3FBBC9E14F86D8660A065848B821347D04521578D4B789FD57231185DF92F45C5733C7912C291D7B13E649B094B33B1B75151C0E4E71E45CCDFD5217DC9F3EF39C3D324CA460DDC40C45CC27B2E421A2B409A47FAAEFD65F8A7F58A269B38CFD9C18210856A493A6624141677F5E95DF040103DF03141CC9BA05BC70F3D049F817404051122E35AC9683",
            //UPI 84
            "9F0605A0000003339F220184DF05083230323831323331DF060101DF070101DF0281B0F9EA5503CFE43038596C720645A94E0154793DE73AE5A935D1FB9D0FE77286B61261E3BB1D3DFEC547449992E2037C01FF4EFB88DA8A82F30FEA3198D5D16754247A1626E9CFFB4CD9E31399990E43FCA77C744A93685A260A20E6A607F3EE3FAE2ABBE99678C9F19DFD2D8EA76789239D13369D7D2D56AF3F2793068950B5BD808C462571662D4364B30A2582959DB238333BADACB442F9516B5C336C8A613FE014B7D773581AE10FDF7BDB2669012DDF040103DF03144D4E6D415F2CF8C394D40C49FB2459110578CF22",
            //UPI 85
            "9F0605A0000003339F220185DF05083230323831323331DF060101DF070101DF0281F8CD026B3E11A7234EFC24FB5976D9F51F7188A1598861AA8A6CA8D9A55300C6E6C39ED97E128973306E7D15DF603823A2C0C2E4C01C5AC0D4E71127DFEC69F2B17DAB12F2E8A84CD30AFC791AE71CD6D69D1B7E7648B2F0BB2140791C585E9CAC6642230B13C81A66E52E927681594EC08CFB30E10658F4199B8BF48B55F140925DEEEF4341E2C6C91E039944A5C44DD72379C2227F02105F462C0E977A2E79D2841143941EB4B4BC1ADAC274E3B0129DE7FDCC77C75BBC29A2861DCE7F748EBEE1E69339348667B729C2900EC6A6D43881622555FA8F8B85E18BD2B8B6F56EBD47643181FF7039D883CB5D723D9DEBD073A5A0CD7B980F0DDF040103DF031496C22F92B7644934F03B4065F1C37BC9DBEA45B0",
            //UPI 0A
            "9F0605A0000003339F22010ADF05083230333031323331DF060101DF070101DF028180B2AB1B6E9AC55A75ADFD5BBC34490E53C4C3381F34E60E7FAC21CC2B26DD34462B64A6FAE2495ED1DD383B8138BEA100FF9B7A111817E7B9869A9742B19E5C9DAC56F8B8827F11B05A08ECCF9E8D5E85B0F7CFA644EFF3E9B796688F38E006DEB21E101C01028903A06023AC5AAB8635F8E307A53AC742BDCE6A283F585F48EFDF040103DF0314C88BE6B2417C4F941C9371EA35A377158767E4E3",
            //UPI 0B
            "9F0605A0000003339F22010BDF05083230333031323331DF060101DF070101DF0281F8CF9FDF46B356378E9AF311B0F981B21A1F22F250FB11F55C958709E3C7241918293483289EAE688A094C02C344E2999F315A72841F489E24B1BA0056CFAB3B479D0E826452375DCDBB67E97EC2AA66F4601D774FEAEF775ACCC621BFEB65FB0053FC5F392AA5E1D4C41A4DE9FFDFDF1327C4BB874F1F63A599EE3902FE95E729FD78D4234DC7E6CF1ABABAA3F6DB29B7F05D1D901D2E76A606A8CBFFFFECBD918FA2D278BDB43B0434F5D45134BE1C2781D157D501FF43E5F1C470967CD57CE53B64D82974C8275937C5D8502A1252A8A5D6088A259B694F98648D9AF2CB0EFD9D943C69F896D49FA39702162ACB5AF29B90BADE005BC157DF040103DF0314BD331F9996A490B33C13441066A09AD3FEB5F66C",
            //UPI 0C
            "9F0605A0000003339F22010CDF05083230333031323331DF060101DF070101DF028190DED9E1BC8E749CAD749484BFB472445BC81FFAA89707648C342AA30D1BE60D5ED0F6CEABA25C683D4503CB11CAF91A39727593CF2BEEAE8032EFACC44FDF8DA31D6007139D4595E8655C7495CF46A9D593A83E3C65B2CBF2AF1EEA02D1F96951A946616B5AB21CA0BF34D12D05F6AE183508A7AC7A46913BDCE5FDC3914CA750018B130CA5BAD49AD8C02291ACA5CFFDDF040103DF0314D7DD7AAC8B67A9A3CC72F35F5D96F265E16EB3FE",

            //JCB 07
            "9F0605A0000000659F220107DF05083230323931323331DF060101DF070101DF028180B8DAB883EF1B5763E4F861F9EA3044B276635D402F3AE5E6B6C0547E368E79A36366DAC5609B6EC486DA1A8D2002CA4F4EFC2CB0EC1573A0B0917969EB60645BAEDF11C050C5D07FED817D11E84A174859A0DAE7F7935F109229C0AC4EE5BFB3D65533A679F0486C5AEFCC937379833BEC45D79DCF97B5228B1910FA03765331DF0403010001DF03144896DD5A9EB5B11B9DCCA6DFE336C009F69F509A",
            //JCB 08 - TEST
            "9F0605A0000000659F220108DF05083230323931323331DF060101DF070101DF028180B74670DAD1DC8983652000E5A7F2F8B35DFD083EE593E5BA895C95729F2BADE9C8ABF3DD9CE240C451C6CEFFC768D83CBAC76ABB8FEA58F013C647007CFF7617BAC2AE3981816F25CC7E5238EF34C4F02D0B01C24F80C2C65E7E7743A4FA8E23206A23ECE290C26EA56DB085C5C5EAE26292451FC8292F9957BE8FF20FAD53E5DF040103DF0314DD36D5896228C8C4900742F107E2F91FE50BC7EE",
            //JCB 09 - Live
            "9F0605A0000000659F220109DF05083230313231323331DF060101DF070101DF028180B72A8FEF5B27F2B550398FDCC256F714BAD497FF56094B7408328CB626AA6F0E6A9DF8388EB9887BC930170BCC1213E90FC070D52C8DCD0FF9E10FAD36801FE93FC998A721705091F18BC7C98241CADC15A2B9DA7FB963142C0AB640D5D0135E77EBAE95AF1B4FEFADCF9C012366BDDA0455C1564A68810D7127676D493890BDDF040103DF03144410C6D51C2F83ADFD92528FA6E38A32DF048D0A",
            //JCB 10 - Live
            "9F0605A0000000659F220110DF05083230333231323331DF060101DF070101DF02819099B63464EE0B4957E4FD23BF923D12B61469B8FFF8814346B2ED6A780F8988EA9CF0433BC1E655F05EFA66D0C98098F25B659D7A25B8478A36E489760D071F54CDF7416948ED733D816349DA2AADDA227EE45936203CBF628CD033AABA5E5A6E4AE37FBACB4611B4113ED427529C636F6C3304F8ABDD6D9AD660516AE87F7F2DDF1D2FA44C164727E56BBC9BA23C0285DF040103DF0314C75E5210CBE6E8F0594A0F1911B07418CADB5BAB",
            //JCB 11 - Test
            "9F0605A0000000659F220111DF05083230333231323331DF060101DF070101DF0281B0A2583AA40746E3A63C22478F576D1EFC5FB046135A6FC739E82B55035F71B09BEB566EDB9968DD649B94B6DEDC033899884E908C27BE1CD291E5436F762553297763DAA3B890D778C0F01E3344CECDFB3BA70D7E055B8C760D0179A403D6B55F2B3B083912B183ADB7927441BED3395A199EEFE0DEBD1F5FC3264033DA856F4A8B93916885BD42F9C1F456AAB8CFA83AC574833EB5E87BB9D4C006A4B5346BD9E17E139AB6552D9C58BC041195336485DF040103DF0314D9FD62C9DD4E6DE7741E9A17FB1FF2C5DB948BCB",
            //JCB 12 - LIVE
            "9F0605A0000000659F220112DF05083230333231323331DF060101DF070101DF0281B0ADF05CD4C5B490B087C3467B0F3043750438848461288BFEFD6198DD576DC3AD7A7CFA07DBA128C247A8EAB30DC3A30B02FCD7F1C8167965463626FEFF8AB1AA61A4B9AEF09EE12B009842A1ABA01ADB4A2B170668781EC92B60F605FD12B2B2A6F1FE734BE510F60DC5D189E401451B62B4E06851EC20EBFF4522AACC2E9CDC89BC5D8CDE5D633CFD77220FF6BBD4A9B441473CC3C6FEFC8D13E57C3DE97E1269FA19F655215B23563ED1D1860D8681DF040103DF0314874B379B7F607DC1CAF87A19E400B6A9E25163E8",
            //JCB 14 - Live
            "9F0605A0000000659F220114DF05083230333231323331DF060101DF070101DF0281F8AEED55B9EE00E1ECEB045F61D2DA9A66AB637B43FB5CDBDB22A2FBB25BE061E937E38244EE5132F530144A3F268907D8FD648863F5A96FED7E42089E93457ADC0E1BC89C58A0DB72675FBC47FEE9FF33C16ADE6D341936B06B6A6F5EF6F66A4EDD981DF75DA8399C3053F430ECA342437C23AF423A211AC9F58EAF09B0F837DE9D86C7109DB1646561AA5AF0289AF5514AC64BC2D9D36A179BB8A7971E2BFA03A9E4B847FD3D63524D43A0E8003547B94A8A75E519DF3177D0A60BC0B4BAB1EA59A2CBB4D2D62354E926E9C7D3BE4181E81BA60F8285A896D17DA8C3242481B6C405769A39D547C74ED9FF95A70A796046B5EFF36682DC29DF040103DF0314C0D15F6CD957E491DB56DCDD1CA87A03EBE06B7B",
            //JCB 0F - Test
            "9F0605A0000000659F22010FDF05083230333231323331DF060101DF070101DF0281909EFBADDE4071D4EF98C969EB32AF854864602E515D6501FDE576B310964A4F7C2CE842ABEFAFC5DC9E26A619BCF2614FE07375B9249BEFA09CFEE70232E75FFD647571280C76FFCA87511AD255B98A6B577591AF01D003BD6BF7E1FCE4DFD20D0D0297ED5ECA25DE261F37EFE9E175FB5F12D2503D8CFB060A63138511FE0E125CF3A643AFD7D66DCF9682BD246DDEA1DF040103DF03142A1B82DE00F5F0C401760ADF528228D3EDE0F403"


//https://www.eftlab.com/knowledge-base/243-ca-public-keys/

    };

    private static final byte ID_TAM_KEY = 0;
    private static final byte ID_TPM_KEY = 1;
    private static final byte ID_TM_KEY = 2;
    private static final byte ID_TOPM_KEY = 3;
    private static final byte ID_TP_KEY = 0;
    private static final byte ID_TA_KEY = 1;
    private static final byte ID_TD_KEY = 2;
    private static final byte ID_TOP_KEY = 3;
    private static final byte ID_TE_KEY = 4;

    private static final String TR_TYPE_CONSUME = "00";
    private static final String TR_TYPE_CASH = "01";
    private static final int SUCCESS = 0;
    private static final int ERROR = -1;

    // ext 모듈 내 CentermListener 와 맞춰야 됨
    private static final int MSG_INFO = 0;
    private static final int MSG_CARD_TIMEOUT = 1;
    private static final int MSG_CARD_DATA_READY = 2;
    private static final int MSG_CARD_APPROVED = 3;
    private static final int MSG_CARD_REFUSED = 4;
    private static final int MSG_CARD_ABORTED = 5;
    private static final int MSG_MAC_GENERATED = 6;
    private static final int MSG_DISCONNECTED = 7;

    // ext 모듈 내 ReqOpenWay.java 와 맞춰야 함
    private static final String ENTRY_INIT = "00";
    private static final String ENTRY_IC_FIRST = "01";
    private static final String ENTRY_MS = "10";
    private static final String ENTRY_IC = "20";
    private static final String ENTRY_IC_FB = "21";
    private static final String ENTRY_RF = "30";
    private static final String ENTRY_RF_FB = "31";

    private static final int BEST_WIDTH = 640;
    private static final int BEST_HEIGHT = 480;
    private static final int SPIN_DEGREE = 90;
    private static final int CAMERA_DISPLAY_EFFECT = 0;

    private final ISender sender;
    private AidlDeviceManager manager;
    private final ServiceConnection conn;
    private AidlEMVL2 pboc2;
    private AidlPinPad pinPad;
    private boolean offlinePinEntered;
    private String offlinePin;
    private RequestPinCallback requestPinCallback;

    private boolean isSimpleFlow;
    private boolean isConfirmCardNo;

    private interface RequestPinCallback {
        void call(String pin);
    }

    public static boolean support(Context context) {
        for (PackageInfo pi : context.getPackageManager().getInstalledPackages(0)) {
            if (pi.packageName.equals(SERVICE_PACKAGE_NAME)) {
                Log.d(TAG, "Centerm package found");
                return true;
            }
        }

        return false;
    }

    public CentermDeviceManager(final Context context) {
        sender = (ISender) context;
        CompactUtil.instance(context.getApplicationContext());

        final Intent intent = new Intent();
        intent.setPackage(SERVICE_PACKAGE_NAME);
        intent.setAction(SERVICE_ACTION);

        conn = new ServiceConnection() {
            @Override
            public void onServiceDisconnected(ComponentName name) {
                Log.d(TAG, "Centerm service disconnected");
                send(MSG_DISCONNECTED, "device service disconnected");
                pboc2 = null;
                pinPad = null;
                manager = null;

                // 서비스 프로세스가 죽었을 경우 재연결을 시도함
                context.bindService(intent, conn, Context.BIND_AUTO_CREATE);
            }

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Log.d(TAG, "Centerm service connected");
                manager = AidlDeviceManager.Stub.asInterface(service);

                if (manager == null) {
                    Log.w(TAG, "Fail to get AidlDeviceManager.Stub.asInterface");
                    return;
                }

                try {
                    pboc2 = AidlEMVL2.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_PBOC2));
                } catch (Throwable e) {
                    Log.e(TAG, "CentermDeviceManager", e);
                }

                try {
                    pinPad = AidlPinPad.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_PINPAD));
                } catch (Throwable e) {
                    Log.e(TAG, "CentermDeviceManager", e);
                }
            }
        };

        context.bindService(intent, conn, Context.BIND_AUTO_CREATE);
    }

    public void destroy() {
        ((Context) sender).unbindService(conn);
        pboc2 = null;
        pinPad = null;
        manager = null;
    }

    public void printImage(byte[] data, IResult result) {
        Log.d(TAG, "[PRINT][CentermDeivceManager]print image");
        Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);

        if (bitmap == null) {
            Log.w(TAG, "Bitmap cannot be created");
            result.set(ERROR);
            return;
        }

        try {
            AidlPrinter printer = AidlPrinter.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_PRINTERDEV));

            if (printer == null) {
                Log.w(TAG, "Printer service is null");
                result.set(-1);
                return;
            }

            int r = printer.printBmpFastSync(bitmap, Constant.ALIGN.LEFT);

            // 에러 코드는 DeviceErrorCode.DEVICE_PRINTER 참조
            if (r == DeviceErrorCode.DEVICE_PRINTER.DEVICE_OK) {
                printer.spitPaper(80);
            }

            // printData() 에러 발생 시 양수로 나옴. 에러 발생 시 음수로 나와야 함
            result.set(-r);
            return;
        } catch (Throwable e) {
            Log.e(TAG, "printImage", e);
        }

        result.set(-1);
    }

    public void printText(String data, IResult result) {
        Log.d(TAG, "[PRINT][CentermDeivceManager]print text");
        CentermPrintFormat printFormat = new CentermPrintFormat();

        try {
            AidlNewPrinter printer = AidlNewPrinter.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_NEW_PRINTER));

            if (printer == null) {
                Log.w(TAG, "printer service is null");
                result.set(-1);
                return;
            }

            PrinterState state = printFormat.print(printer, data);
            Log.d(TAG, "printer state: " + state.getStateMsg());
            result.set(-state.getStateCode());
            return;
        } catch (Throwable e) {
            Log.e(TAG, "printText", e);
        }

        result.set(-1);
    }

    /**
     * 카드 리더기 요청
     *
     * @param cmd    json 스트링
     *               null: 연결 확인
     *               {cmd: ready} 무결성 검증 (현재 연결 확인과 동일)
     *               {cmd: loadKeys, [{type: 키타입, key: 키, {...}, ...}]} 키 로드
     *               {cmd: loadKeySet, keySet: 키셋} 키셋 로드
     *               {cmd: loadAID} AID 로드
     *               {cmd: loadCA} CA PK 로드
     *               {cmd: consume, amount: 금액, pinEntry: PIN 입력 여부, cardEntryType: 카드입력종류} 결제용 카드 읽기
     *               {cmd: set, simpleFlow: true/false, confirmCardNo: true/false} 설정
     *               {cmd: return} 결제 취소용 카드 읽기
     *               {cmd: cancelTransaction} 카드 읽기 취소
     *               {cmd: onlineProcessResult, emv8aTag: 온라인 데이터}
     *               {cmd: mac, data: MAC 생성할 데이터} MAC 생성
     *               {cmd: test} 테스트
     * @param result 응답 콜백
     */
    public void requestCardReader(byte[] cmd, IResult result) {
        if (cmd == null) {
            result.set(pboc2 != null ? SUCCESS : ERROR);
            return;
        }

        if (pboc2 == null) {
            result.set(ERROR);
            return;
        }

        try {
            JSONObject json = new JSONObject(new String(cmd));
            String command = json.getString("cmd");

            switch (command) {
                case "ready":
                    result.set(pboc2 != null ? SUCCESS : ERROR);
                    break;
                case "loadKeys":
                    JSONArray array = json.getJSONArray("keys");

                    for (int i = 0; i < array.length(); i++) {
                        JSONObject j = array.getJSONObject(i);
                        String type = j.getString("type");
                        String key = j.getString("key");
                        String checkValue = j.has("checkValue") ? j.getString("checkValue") : null;
                        String masterType = j.has("masterType") ? j.getString("masterType") : null;

                        if (!loadKey(type, key, checkValue, masterType)) {
                            result.set(i + 1); // i 번째 키에서 에러 발생
                            return;
                        }
                    }

                    result.set(SUCCESS);
                    break;
                case "loadKeySet":
                    String keySet = json.has("keySet") ? json.getString("keySet") : "default";

                    if (!loadKeySet(keySet)) {
                        Log.d(TAG, "loadKeySet: failed");
                        result.set(ERROR);
                        break;
                    }

                    result.set(SUCCESS);
                    break;
                case "loadAID":
                    boolean useUSD = json.has("useUSD") && json.getBoolean("useUSD");

                    if (!clearAllAID()) {
                        Log.d(TAG, "clearAllAid: failed");
                        result.set(ERROR);
                        break;
                    }

                    if (!addAID(useUSD)) {
                        Log.d(TAG, "addAID: failed");
                        result.set(ERROR);
                        break;
                    }

                    result.set(SUCCESS);
                    break;
                case "loadCA":
                    if (!clearAllCA()) {
                        Log.d(TAG, "clearAllCA: failed");
                        result.set(ERROR);
                        break;
                    }

                    if (!addCA()) {
                        Log.d(TAG, "addCA: failed");
                        result.set(ERROR);
                        break;
                    }

                    result.set(SUCCESS);
                    break;
                case "readCard":
                    String trType = json.getString("transactionType");
                    String amount = json.getString("amount");
                    boolean pinEntryMsr = json.getBoolean("pinEntryMsr");
                    boolean pinEntryRf = json.getBoolean("pinEntryRf");
                    String cardEntryType = json.getString("cardEntryType");
                    readCard(trType, amount, pinEntryMsr, pinEntryRf, cardEntryType);
                    result.set(SUCCESS);
                    break;
                case "set":
                    if (json.has("simpleFlow")) {
                        isSimpleFlow = json.getBoolean("simpleFlow");
                    }

                    if (json.has("confirmCardNo")) {
                        isConfirmCardNo = json.getBoolean("confirmCardNo");
                    }

                    result.set(SUCCESS);
                    break;
                case "cancelTransaction":
                    pboc2.cancelCheckCard();
                    pboc2.abortPBOC();
                    result.set(SUCCESS);
                    break;
                case "onlineProcessResult":
                    String emv8aTag = json.getString("emv8aTag");
                    onlineProcessResult(emv8aTag);
                    result.set(SUCCESS);
                    break;
                case "mac":
                    String data = json.getString("data");
                    boolean useTDK = json.optBoolean("useTDK");
                    generateMac(data, useTDK);
                    result.set(SUCCESS);
                    break;
                case "test":
                    initOfflinePinPad();
                    requestOfflinePin(null);
                    result.set(SUCCESS);
                    break;
                default:
                    Log.d(TAG, "Unknown command: " + command);
                    result.set(ERROR);
                    break;
            }
        } catch (Throwable e) {
            Log.e(TAG, "requestCardReader", e);
            result.set(ERROR);
        }
    }

    private boolean clearAllAID() throws RemoteException {
        return pboc2.updateAID(EMVConstant.AidCapkOptFlag.AID_CAPK_OPT_REMOVEALL_FLAG, null);
    }

    private boolean addAID(boolean useUSD) throws RemoteException {
        //String currency = useUSD ? AID_CURRENCY_USD : AID_CURRENCY_RUB;
        String currency = AID_CURRNECY_KZT;

        for (String aid : TEST_CENTERM_AID) {
            aid = aid + AID_ATTACH_STR1 + "9F1A02" + currency + "5F2A02" + currency;

            if (!pboc2.updateAID(EMVConstant.AidCapkOptFlag.AID_CAPK_OPT_ADDORUPDATE_FLAG, aid)) {
                return false;
            }
        }

        return true;
    }

    private boolean clearAllCA() throws RemoteException {
        return pboc2.updateCAPK(EMVConstant.AidCapkOptFlag.AID_CAPK_OPT_REMOVEALL_FLAG, null);
    }

    private boolean addCA() throws RemoteException {

        boolean retValue = true;

        for (String ca : TEST_CENTERM_CAPK) {

            if (!pboc2.updateCAPK(EMVConstant.AidCapkOptFlag.AID_CAPK_OPT_ADDORUPDATE_FLAG, ca)) {
                System.out.println("LoadCAPK ERR[" + ca + "]");
                retValue = false;
            } else {
                System.out.println("LoadCAPK OK[" + ca + "]");
            }
        }

        return retValue;
    }

    /*
        https://www.emvlab.org/descalc/ 에서 암호화 한 키를 구할 수 있음
        1. Encrypted 키 구하기
           Key 입력에 clear master 키를 hex 값으로 입력
           Input Data 입력에 clear work 키를 hex 값으로 입력
           ECB 선택
           Encrypt 실행 시 나오는 출력 값이 암호화 된 키임
        2. Check Value 구하기
           Key 입력에 clear 키를 입력
           Input Data 입력에 0000000000000000 입력
           ECB 선택
           Encrypt 실행 시 나오는 출력 값 중 4바이트가 check value 임
    */
    private boolean loadKey(String type, String key, String checkValue, String masterType) {
        boolean success = false;
        byte[] k = HexUtil.hexStringToByte(key);
        byte[] v = null;
        byte[] kv = k;

        if (checkValue != null && checkValue.length() == 8) {
            v = HexUtil.hexStringToByte(checkValue);
            kv = new byte[k.length + v.length];
            System.arraycopy(k, 0, kv, 0, k.length);
            System.arraycopy(v, 0, kv, k.length, v.length);
        }

        try {
            // KLK 만 clean 키가 들어가고, 나머지는 encryption 된 키들임
            switch (type) {
                case "KLK":
                    success = pinPad.downTek((byte) 0, k, v);
                    break;
                case "TAMK":
                    success = pinPad.downTMK(k, v, ID_TAM_KEY);
                    break;
                case "TPMK":
                    success = pinPad.downTMK(k, v, ID_TPM_KEY);
                    break;
                case "TMK":
                    success = pinPad.downTMK(k, v, ID_TM_KEY);
                    break;
                case "TOPMK":
                    success = pinPad.downTMK(k, v, ID_TOPM_KEY);
                    break;
                case "TDK":
                    success = pinPad.disperseWkey(PinPadBuilder.WORKKEYTYPE.MAK, kv, getMasterKey(masterType, ID_TAM_KEY), ID_TD_KEY);
                    break;
                case "TAK":
                    success = pinPad.disperseWkey(PinPadBuilder.WORKKEYTYPE.MAK, kv, getMasterKey(masterType, ID_TAM_KEY), ID_TA_KEY);
                    break;
                case "TPK":
                    success = pinPad.disperseWkey(PinPadBuilder.WORKKEYTYPE.PIK, kv, getMasterKey(masterType, ID_TPM_KEY), ID_TP_KEY);
                    break;
                case "TOPK":
                    success = pinPad.disperseWkey(PinPadBuilder.WORKKEYTYPE.PIK, kv, getMasterKey(masterType, ID_TM_KEY), ID_TOP_KEY);
                case "TEK":
                    success = pinPad.disperseWkey(PinPadBuilder.WORKKEYTYPE.MAK, kv, getMasterKey(masterType, ID_TM_KEY), ID_TE_KEY);
            }
        } catch (Throwable e) {
            Log.e(TAG, "loadKey", e);
        }

        Log.d(TAG, "loadKey: Key " + type + (success ? " saved" : "  cannot saved"));
        return success;
    }

    private byte getMasterKey(String type, byte defaultValue) {
        if (type != null) {
            switch (type) {
                case "TAMK":
                    return ID_TAM_KEY;
                case "TPMK":
                    return ID_TPM_KEY;
                case "TMK":
                    return ID_TM_KEY;
                case "TOPMK":
                    return ID_TOPM_KEY;
            }
        }

        return defaultValue;
    }

    private boolean loadKeySet(String set) {

        boolean success = false;

        String klk;

        if (ALLOW_INIT_KEYS) {
            switch (set) {
                case "halyk":
                    // Halyk Bank 용
                    klk = "6F2D656000A672C6485959CADE8EC600";
                    success = loadKey("KLK", klk, "062CFEE7", null);
                    break;
                case "test":
                    // OpenWay CH9. Mac Implementation 에 나오는 예제 값을 확인하기 위한 키 설정
                    klk = "0123456789ABCDEFFEDCBA9876543210";
                    success = loadKey("KLK", klk, null, null) &&
                            loadKey("TAMK", "1A4D672DCA6CB3351FD1B02B237AF9AE", null, null) &&
                            loadKey("TPMK", "1A4D672DCA6CB3351FD1B02B237AF9AE", null, null) &&
                            loadKey("TDK", "1A4D672DCA6CB3351A4D672DCA6CB335", null, "TAMK") &&
                            loadKey("TAK", "1A4D672DCA6CB3351A4D672DCA6CB335", null, "TAMK") &&
                            loadKey("TPK", "1A4D672DCA6CB3351A4D672DCA6CB335", null, "TPMK");
                    break;
                case "default":
                default:
                    klk = "0123456789ABCDEFFEDCBA9876543210";
                    success = loadKey("KLK", klk, "08D7B4FB", null) &&
                            loadKey("KLK", "0123456789ABCDEFFEDCBA9876543210", "08D7B4FB", null) &&
                            loadKey("TAMK", "1A4D672DCA6CB3351FD1B02B237AF9AE", "08D7B4FB", null) &&
                            loadKey("TPMK", "1A4D672DCA6CB3351FD1B02B237AF9AE", "08D7B4FB", null) &&
                            loadKey("TDK", "1A4D672DCA6CB3351FD1B02B237AF9AE", "08D7B4FB", "TAMK") &&
                            loadKey("TAK", "1A4D672DCA6CB3351FD1B02B237AF9AE", "08D7B4FB", "TAMK") &&
                            loadKey("TPK", "1A4D672DCA6CB3351FD1B02B237AF9AE", "08D7B4FB", "TPMK");
                    break;
            }
        }

        if (success) {
            Map<String, String> data = new HashMap<>();
            data.put("1", klk);
            saveSettings(data);
        }

        return success;
    }

    private void saveSettings(Map<String, String> data) {
        File sd = Environment.getExternalStorageDirectory();

        if (!sd.canWrite()) {
            return;
        }

        File dir = new File(sd + "/" + FILE_DIR);

        if (!dir.exists()) {
            //noinspection ResultOfMethodCallIgnored
            dir.mkdirs();
        }

        File file = new File(sd + "/" + FILE_DIR + "/" + FILE_NAME);

        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(file));

            for (String key : data.keySet()) {
                String value = data.get(key);

                if (value != null) {
                    writer.write(key + "=" + value);
                    writer.newLine();
                }
            }

            writer.close();
        } catch (Throwable e) {
            Log.e(TAG, "saveSettings", e);
        }
    }

    private void readCard(final String trType, final String amount, final boolean pinEntryMsr, final boolean pinEntryRf, final String cardEntryType) throws RemoteException {
        final boolean fallback = ENTRY_IC_FB.equals(cardEntryType) || ENTRY_RF_FB.equals(cardEntryType);
        initOfflinePinPad();

        // 의도적으로 pboc2, pinpad 를 새로 할당 받음 (좀 더 안정적으로 동작하는 것으로 보임)
        pboc2 = AidlEMVL2.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_PBOC2));
        pinPad = AidlPinPad.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_PINPAD));

        pboc2.checkCard(true, !fallback, !fallback, READ_CARD_TIMEOUT, new AidlCheckCardListener.Stub() {
            @Override
            public void onFindMagCard(ParcelableTrackData parcelableTrackData) {
                /*
                    Service code values common in financial cards:

                    First digit
                    1: International interchange OK
                    2: International interchange, use IC (chip) where feasible   <-- IC 카드
                    5: National interchange only except under bilateral agreement
                    6: National interchange only except under bilateral agreement, use IC (chip) where feasible  <-- IC 카드
                    7: No interchange except under bilateral agreement (closed loop)
                    9: Test

                    Second digit
                    0: Normal
                    2: Contact issuer via online means
                    4: Contact issuer via online means except under bilateral agreement

                    Third digit
                    0: No restrictions, PIN required
                    1: No restrictions
                    2: Goods and services only (no cash)
                    3: ATM only, PIN required
                    4: Cash only
                    5: Goods and services only (no cash), PIN required
                    6: No restrictions, use PIN where feasible
                    7: Goods and services only (no cash), use PIN where feasible
                 */
                try {
                    String svcCode = parcelableTrackData.getServiceCode();

                    if (svcCode == null || svcCode.length() != 3) {
                        send(MSG_CARD_ABORTED, "invalid_card");
                        return;
                    }

                    if (!svcCode.startsWith("1") && !fallback) {
                        send(MSG_CARD_ABORTED, "insert_ic_first", "retry", ENTRY_IC_FIRST);
                        return;
                    }

                    startMsTransaction(parcelableTrackData, amount, pinEntryMsr, fallback ? cardEntryType : ENTRY_MS);
                } catch (Throwable e) {
                    Log.e(TAG, "readCard", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void onSwipeCardFail() {
                // Swipe magnetic stripe card failed
                send(MSG_CARD_ABORTED, "invalid_card");
            }

            @Override
            public void onFindICCard() {
                try {
                    startIcRfTransaction(trType, amount, pinEntryRf, ENTRY_IC);
                } catch (Throwable e) {
                    Log.e(TAG, "onFindICCard", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void onFindRFCard() {
                try {
                    startIcRfTransaction(trType, amount, pinEntryRf, ENTRY_RF);
                } catch (Throwable e) {
                    Log.e(TAG, "onFindRFCard", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void onTimeout() {
                send(MSG_CARD_TIMEOUT, "Search card timeout");
            }

            @Override
            public void onCanceled() {
                Log.d(TAG, "Searching card canceled");
                send(MSG_CARD_ABORTED, "Searching card canceled");
            }

            @Override
            public void onError(int i) {
                Log.d(TAG, "Searching card error: " + i);
                send(MSG_CARD_ABORTED, "card_reader_error@@Searching card error:" + i);
            }
        });

        // checkCard()에서 에러 발생 시 이벤트 발생시키지 않기 위해 의도적으로 아래에 둠
        notice(cardEntryType);
    }

    private void notice(String cardEntryType) {
        switch (cardEntryType) {
            case ENTRY_INIT:
                send(MSG_INFO, "insert_ic_card");
                break;
            case ENTRY_IC_FIRST:
                send(MSG_INFO, "insert_ic_first");
                break;
            case ENTRY_IC_FB:
            case ENTRY_RF_FB:
            default:
                send(MSG_INFO, "insert_ms_card");
                break;
        }
    }

    private void startMsTransaction(final ParcelableTrackData data, String amount, boolean pinEntry, final String cardEntryType) {
        if (pinEntry) {
            requestPin(data.getCardNo(), amount, pin -> {
                if (pin == null) {
                    send(MSG_CARD_ABORTED, "invalid_pin");

                    try {
                        pboc2.abortPBOC();
                    } catch (Throwable e) {
                        Log.e(TAG, "startMsTransaction", e);
                    }

                    return;
                }

                send(MSG_CARD_DATA_READY, "MS card data ready",
                        "cardType", data.getCardType(), // 0: magnetic stripe card, 1: magnetic stripe card with chip  이 값은 동작 안하는듯..
                        "cardNo", data.getCardNo(),
                        "maskedCardNo", data.getMaskedCardNo(),
                        "expirationDate", data.getExpireDate(),
                        "serviceCode", data.getServiceCode(),
                        "track1", new String(data.getFirstTrackData()),
                        "track2", new String(data.getSecondTrackData()),
                        "track3", new String(data.getThirdTrackData()),
                        "trackEncrypted", new String(data.getTrackDataEncrypeData()),
                        "pin", pin,
                        "cardEntryType", cardEntryType);
            });
        } else {
            send(MSG_CARD_DATA_READY, "MS card data ready",
                    "cardType", data.getCardType(), // 0: magnetic stripe card, 1: magnetic stripe card with chip
                    "cardNo", data.getCardNo(),
                    "maskedCardNo", data.getMaskedCardNo(),
                    "expirationDate", data.getExpireDate(),
                    "serviceCode", data.getServiceCode(),
                    "track1", new String(data.getFirstTrackData()),
                    "track2", new String(data.getSecondTrackData()),
                    "track3", new String(data.getThirdTrackData()),
                    "trackEncrypted", new String(data.getTrackDataEncrypeData()),
                    "cardEntryType", cardEntryType);
        }
    }

    private void startIcRfTransaction(final String trType, final String amount, final boolean pinEntry, final String cardEntryType) throws RemoteException {
        EmvTransData data = new EmvTransData();

        if (ENTRY_RF.equals(cardEntryType)) {
            data.setSlotType((byte) EMVConstant.SlotType.SLOT_TYPE_RF);
        } else {
            data.setSlotType((byte) EMVConstant.SlotType.SLOT_TYPE_IC);
        }

        if (isSimpleFlow) {
            data.setTransTypeSimpleFlow(true);
        }

        if (isConfirmCardNo) {
            data.setConfirmCardNo(true);
        }

        switch (trType) {
            case TR_TYPE_CONSUME:
                data.setTranstype((byte) EMVConstant.TransType.TRANS_TYPE_CONSUME);
                break;
            case TR_TYPE_CASH:
                data.setTranstype(EMVConstant.TransType.TRANSTYPE_CASH);
                break;
        }

        data.setRequestAmtPosition((byte) EMVConstant.AmtPosition.BEFORE_DISPLAY_CARD_NUMBER);
        data.setIsEcashEnable(false);
        data.setIsForceOnline(true);
        data.setIsSmEnable(false); // national secret algorithm? 지원
        data.setEMVFlow((byte) EMVConstant.EMVFlowSelect.EMV_FLOW_PBOC);

        pboc2.processPBOC(data, new PBOCListener.Stub() {
            private String cardNo;
            private String pin;

            @Override
            public void onConfirmCardInfo(CardInfoData arg0) {
                Log.d(TAG, "onConfirmCardInfo [" + arg0 + "]");

                try {
                    cardNo = arg0.getCardno();
                    pboc2.importConfirmCardInfoRes(true);
                } catch (Throwable e) {
                    Log.e(TAG, "onConfirmCardInfo", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void onError(int arg0) {
                Log.d(TAG, "Calling error: " + arg0);
                send(MSG_CARD_ABORTED, "card_reader_error@@Calling error:" + arg0);
            }

            @Override
            public void onSignatureRequest() {

            }

            @Override
            public void onCvmFlagVerify() {

            }

            @Override
            public void onReadCardLoadLog(String arg0, String arg1, CardLoadLog[] arg2) {
                Log.d(TAG, "Read log of credit for load success");
            }

            @Override
            public void onReadCardOffLineBalance(String firstMoneyCode, String firstBalance, String secondMoneyCode, String secondBalance) {
                Log.d(TAG, "Offline balance query ends with the balance: " + firstBalance);
            }

            @Override
            public void onReadCardTransLog(CardTransLog[] arg0) {
                Log.d(TAG, "Read card transaction logs: " + arg0.length);

                for (CardTransLog log : arg0) {
                    Log.d(TAG, "EMV Log2[" + log.toString() + "]");
                }
            }

            @Override
            public void onRequestOnline() {
                Log.d(TAG, "ON_REQUEST_ONLINE[" + debugICCResult() + "]");

                try {
                    //RF 카드인 경우 PBT/SBT 에 따라 PIN 을 입력받아야 합니다.
                    if (ENTRY_RF.equals(cardEntryType) & pinEntry) {
                        // RF 카드인 경우 onConfirmCardInfo() 를 타지 않음
                        Log.d(TAG, "[onRequestOnline][RF&PIN]Read kernel data");
                        String cardInfo = readKernelData(getCardInfoTag());

                        if (cardInfo == null) {
                            send(MSG_CARD_ABORTED, "card_reader_error@@No card data");
                            return;
                        }

                        TlvData data = new TlvData(cardInfo, true);
                        String cardNo = data.getValueByTag("5A");

                        // 홀수 자리이면 끝에 "F"가 붙어 제거
                        if (cardNo != null && cardNo.endsWith("F")) {
                            cardNo = cardNo.substring(0, cardNo.length() - 1);
                        }

                        if (cardNo == null) {
                            String track2 = data.getValueByTag("57");

                            if (track2 != null) {
                                track2 = convertTrack2(track2);
                                int index = track2.indexOf("=");

                                if (index != -1) {
                                    cardNo = track2.substring(0, track2.indexOf("="));
                                }
                            }
                        }

                        requestPin(cardNo, amount, p -> {
                            pin = p;

                            if (p == null) {
                                send(MSG_CARD_ABORTED, "invalid_pin");

                                try {
                                    pboc2.abortPBOC();
                                } catch (Throwable e) {
                                    Log.e(TAG, "onRequestOnline", e);
                                }

                                return;
                            }

                            sendCardData();
                        });
                    } else {
                        sendCardData();
                    }
                } catch (Throwable e) {
                    Log.e(TAG, "onRequestOnline", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void onTransResult(byte arg0) {
                try {
                    switch (arg0) {
                        case EMVConstant.TransResult.TRANS_RESULT_ABORT:
                            Log.d("GML_ICCEVT", "TRANS_RESULT_ABORT[" + debugICCResult() + "]The kernel process termination");
                            send(MSG_CARD_ABORTED, "card_reader_error@@TRANS_RESULT_ABORT");
                            break;
                        case EMVConstant.TransResult.TRANS_RESULT_APPROVE:
                            Log.d("GML_ICCEVT", "TRANS_RESULT_APPROVE[" + debugICCResult() + "]");
                            sendCardApproved();
                            break;
                        case EMVConstant.TransResult.TRANS_RESULT_FALLBACK:
                            // Fallback, IC card not inserted or damaged or aid public key is not downloaded,
                            // please check the card or aid public key certificate
                            send(MSG_CARD_ABORTED, "insert_ms_card",
                                    "retry", ENTRY_IC.equals(cardEntryType) ? ENTRY_IC_FB : ENTRY_RF_FB);
                            return;
                        case EMVConstant.TransResult.TRANS_RESULT_OTHER:
                            Log.d("GML_ICCEVT", "TRANS_RESULT_OTHER[" + debugICCResult() + "]");
                            send(MSG_CARD_ABORTED, "card_reader_error@@TRANS_RESULT_OTHER");
                            break;
                        case EMVConstant.TransResult.TRANS_RESULT_OTHERINTERFACES:
                            send(MSG_CARD_ABORTED, "use_other_interfaces");
                            break;
                        case EMVConstant.TransResult.TRANS_RESULT_REFUSE:
                            Log.d("GML_ICCEVT", "TRANS_RESULT_REFUSE[" + debugICCResult() + "]");
                            send(MSG_CARD_REFUSED, "invalid_card");
                            break;
                        default:
                            Log.d("GML_ICCEVT", "TRANSACTION_ERROR[" + arg0 + "][" + debugICCResult() + "]");
                            send(MSG_CARD_ABORTED, "card_reader_error@@TRANSACTION_ERROR:" + arg0);
                            break;
                    }

                    pboc2.endPBOC();
                } catch (Throwable e) {
                    Log.e(TAG, "onTransResult", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            private void sendCardData() {
                Log.d(TAG, "[sendCardData]1. Read kernel data");
                String kernelData = readKernelData(getOpenWayF55Tags(), getCardInfoTag());
                String cardNo = null;
                String cardSno = null;
                String track2 = null;
                String expirationDate = "";
                String cardholderName = null;
                String cardName = null;
                String ctName = null;

                if (kernelData != null) {
                    // Visa Paywave 시에 찾아내는 방법
                    // Visa Paywave 시에 9F34 Tag 없어서 OpenWay 송신시 강제로 설정하는 부분
                    if (ENTRY_RF.equals(cardEntryType)) {
                        TlvData tlv = new TlvData(kernelData, true);
                        String tag9F34 = tlv.getValueByTag("9F34");

                        if (tag9F34 == null) {
                            String tag84 = tlv.getValueByTag("84");
                            String rID = "|" + tag84.substring(0, 10) + "|";

                            if (VISA_CONTACTLESS_RID.contains(rID)) {
                                if (pin != null && pin.length() > 0) {
                                    kernelData += "9F3403020000";
                                } else {
                                    kernelData += "9F34031F0000";
                                }
                            }
                        }
                    }

                    TlvData data = new TlvData(kernelData, true);
                    cardNo = data.getValueByTag("5A");

                    if (cardNo != null && cardNo.endsWith("F")) {
                        cardNo = cardNo.substring(0, cardNo.length() - 1);
                    }

                    cardSno = data.getValueByTag("5F34");
                    track2 = data.getValueByTag("57");
                    track2 = convertTrack2(track2);
                    cardholderName = data.getValueByTag("5F20");
                    cardName = data.getValueByTag("9F12");
                    ctName = data.getValueByTag("50");

                    if (track2 != null) {
                        int index = track2.indexOf("=");

                        if (index != -1) {
                            if (cardNo == null) {
                                cardNo = track2.substring(0, index);
                            }

                            expirationDate = track2.substring(index + 1, index + 5);
                        }
                    }

                    if (cardholderName != null) {
                        cardholderName = new String(HexUtil.hexStringToByte(cardholderName)).trim();
                    }

                    if (cardName != null) {
                        cardName = new String(HexUtil.hexStringToByte(cardName));
                    }

                    if (ctName != null) {
                        ctName = new String(HexUtil.hexStringToByte(ctName));
                    }
                }

                /*
                    [참고]
                    여기서 9F27 Ta의 값을 읽어서 Advice required Bit 가 설정되어 있으면 EMV Information Advice 전문을 전송해야 합니다.
                    온라인 Req 전송 전...
                    IC 연산시..  9F27 Tag 읽어내 처리  (이 과정은 2nd AC generation 이후 얻어내야 함)
                        readByte & 0x08 = 0x08 이면 EMV Advice 발송  <-- 처리해야 함
                        readByte & 0x80 = 0x80 이면 ARQC : 온라인 거래 발송  <--처리해야함
                        readByte & 0x40 = 0x40 이면 TC : 오프라인으로 거래 종료  <-- 온라인 거래
                        readByte & 0x02 = 0x02 이면 PIN limit 초과(Pin try limit exceeded)  <-- EMV 에서 처리되어 이벤트로 날아옴
                        readByte & 0x03 = 0x03 이면 발급자 검증 오류 (Issuer authentication failed) <-- EMV 에서 처리되어 이벤트로 날아옴
                        readByte & 0x01 = 0x01 이면 거래 거졀 (Service Not Allowed)  <-- EMV 에서 처리되어 이벤트로 날아옴
                 */

                Log.d(TAG, "[sendCardData]2. Send");
                send(CentermDeviceManager.MSG_CARD_DATA_READY, "IC card data ready",
                        "cardNo", cardNo,
                        "cardSno", cardSno,
                        "expirationDate", expirationDate,
                        "cardholderName", cardholderName,
                        "cardName", cardName,
                        "ctName", ctName,
                        "track2", track2,
                        "kernelData", extractOpenWayF55Tags(kernelData),
                        "pin", pin,
                        "cardEntryType", cardEntryType);
                Log.d(TAG, "[sendCardData]3. Done");
            }

            private void sendCardApproved() {
                Log.d(TAG, "[sendCardApproved]1. Read kernel data");
                String kernelData = readKernelData(getOpenWayF55Tags(), getIssuerScriptResult());
                String sr = null;

                if (kernelData != null) {
                    TlvData tlv = new TlvData(kernelData, true);
                    sr = tlv.getValueByTag("DF31");
                }

                Log.d(TAG, "[sendCardApproved]2. Send");
                send(CentermDeviceManager.MSG_CARD_APPROVED, "Approved",
                        "kernelData", extractOpenWayF55Tags(kernelData),
                        "sr", sr);
                Log.d(TAG, "[sendCardApproved]3. Done");
            }

            private String convertTrack2(String str) {
                if (str == null) {
                    return null;
                }

                int substrIdx = str.lastIndexOf('F');
                if (substrIdx < 0) substrIdx = str.length();

                return str.replaceAll("D", "=").substring(0, substrIdx);
            }

            @Override
            public void requestAidSelect(int arg0, String[] arg1) {
                Log.d(TAG, "Request multiple application selections");

                try {
                    if (!pboc2.importAidSelectRes(1)) {
                        Log.d(TAG, "Fail to select application id");
                    }
                } catch (Throwable e) {
                    Log.e(TAG, "requestAidSelect", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void requestEcashTipsConfirm() {
                Log.d(TAG, "Request confirmation of e-cash support");
            }

            @Override
            public void requestImportAmount(int arg0) {
                try {
                    if (!pboc2.importAmount(amount)) {
                        Log.d(TAG, "Fail to import amount: " + amount);
                    }
                } catch (Throwable e) {
                    Log.e(TAG, "requestImportAmount", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void requestImportPin(int arg0, boolean arg1, String arg2) {
                Log.d(TAG, "Request to enter PIN data [" + arg0 + "][" + arg1 + "][" + arg2 + "]");

                try {
                    if (arg0 == EMVConstant.PinType.PINTYPE_OFFLINE || arg0 == EMVConstant.PinType.PINTYPE_OFFLINE_LASTTIME) {
                        //핀번호 틀릴 경우 빠지도록 작업함..
                        //Offline PIN 잘못 입력되어 3회 오류나면 풀기 너무너무너무 힘듬...
                        //잘못 입력된 경우 동작하지 않도록 코딩
                        if (!arg1) {
                            try {
                                pboc2.abortPBOC();
                            } catch (Throwable e) {
                                Log.e(TAG, "requestImportPin", e);
                            }

                            Log.d(TAG, "Fail to import offline pin");
                            send(MSG_CARD_ABORTED, "invalid_pin");
                            return;
                        }

                        requestOfflinePin(p -> {
                            pin = "OFFLINE";

                            try {
                                if (p != null) {
                                    if (!pboc2.importPin(formatPlainPin(p))) {
                                        Log.d(TAG, "Fail to import pin");
                                        pboc2.abortPBOC();
                                        send(MSG_CARD_ABORTED, "invalid_pin");
                                    }
                                } else {
                                    pboc2.abortPBOC();
                                    send(MSG_CARD_ABORTED, "invalid_pin");
                                }
                            } catch (Throwable e) {
                                Log.e(TAG, "requestImportPin", e);
                            }
                        });
                    } else if (arg0 == EMVConstant.PinType.PINTYPE_ONLINE) {
                    /*
                        MSR : 오프라인 PIN 없음
                              제한금액 이상은 온라인 PIN
                        IC  : 오프라인 PIN 있음
                              온라인 PIN 있음 (PIN 조건은 ICC 에서 이벤트 발생)
                        RF  : 오프라인 PIN 없음
                              제한금액 이상은 온라인 PIN (ICC 에서 온라인 PIN 이벤트 발생할 수 있음. 그 경우 무시해야 함)
                     */
                        if (ENTRY_RF.equals(cardEntryType)) {
                            try {
                                if (!pboc2.importPin(formatPlainPin("0000"))) {
                                    Log.d(TAG, "Fail to import pin");
                                    pboc2.abortPBOC();
                                    send(MSG_CARD_ABORTED, "invalid_pin");
                                }
                            } catch (Throwable e) {
                                Log.e(TAG, "requestImportPin", e);
                            }
                        } else {
                            requestPin(cardNo, amount, p -> {
                                pin = p;

                                try {
                                    if (p != null) {
                                        if (!pboc2.importPin(formatPlainPin("0000"))) {
                                            Log.d(TAG, "Fail to import pin");
                                            pboc2.abortPBOC();
                                            send(MSG_CARD_ABORTED, "invalid_pin");
                                        }
                                    } else {
                                        pboc2.abortPBOC();
                                        send(MSG_CARD_ABORTED, "invalid_pin");
                                    }
                                } catch (Throwable e) {
                                    Log.e(TAG, "requestImportPin", e);
                                }
                            });
                        }
                    }
                } catch (Throwable e) {
                    Log.e(TAG, "requestImportPin", e);
                }
            }

            private String formatPlainPin(String pin) {
                return ("2" + pin.length() + pin + "FFFFFFFFFFFFFFFF").substring(0, 16);
            }

            @Override
            public void requestTipsConfirm(String arg0) {
                Log.d(TAG, "Request to confirm message: " + arg0);

                try {
                    pboc2.importMsgConfirmRes(true);
                } catch (Throwable e) {
                    Log.e(TAG, "requestTipsConfirm", e);
                    send(MSG_CARD_ABORTED, "card_reader_error");
                }
            }

            @Override
            public void requestUserAuth(int arg0, String arg1) {
                Log.d(TAG, "Request for cardholder authentication");
            }
        });
    }

    private String debugICCResult() {
        if (!BuildConfig.DEBUG) {
            return "";
        }

        Log.d(TAG, "[debugICCResult]Read kernel data");
        String kernel = readKernelData(getOpenWayDebug());

        if (kernel == null) {
            return "";
        }

        TlvData data = new TlvData(kernel, true);
        return "9F27(CI) " + data.getValueByTag("9F27")
                + ", 95(TVR) " + data.getValueByTag("95")
                + ", 9F34(CVM) " + data.getValueByTag("9F34")
                + ", DF31(ISR) " + data.getValueByTag("DF31")
                + ", 9F39(07=MChip) " + data.getValueByTag("9F39");
    }

    private void initOfflinePinPad() {
        offlinePinEntered = false;
        offlinePin = null;
        requestPinCallback = null;
    }

    private void requestOfflinePin(RequestPinCallback callback) {
        // 오프라인 PIN 입력인 경우 카드 리더기에서 2번 requestImportPin() 호출함
        // 이미 PIN 이 입력되었다면 바로 callback 을 호출하게 함
        if (offlinePinEntered) {
            callback.call(offlinePin);
            return;
        }

        Context context = (Context) sender;
        Intent intent = new Intent(context, PinPadActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(intent);
        requestPinCallback = callback;
    }

    public void enterOfflinePin(String pin) {
        offlinePinEntered = true;
        offlinePin = pin;

        if (requestPinCallback != null) {
            Log.d(TAG, "Offline pin entered");
            requestPinCallback.call(pin);
        }
    }

    private void requestPin(String cardNo, String amount, final RequestPinCallback callback) {
        Log.d(TAG, "Request to enter PIN data [" + cardNo + "][" + amount + "]");

        try {
            PinInfo pinInfo = new PinInfo(ID_TP_KEY,
                    PinPadBuilder.DATAENCRYPT_MODE.DEFAULT, cardNo,
                    String.valueOf(amount), 4, 6, null,
                    PinPadBuilder.PIN_ENCRYPT_MODE.MODE_ZERO,
                    PinPadBuilder.PIN_CARDCAL.NEED_CARD,
                    PinPadBuilder.PIN_INPUT_TIMES.TIMES_ONCE);
            pinInfo.setShowInputBox(true);
            pinInfo.setCanclable(true);

            pinPad.getPin(pinInfo, new PinPadInputPinCallback.Stub() {
                @Override
                public void onReadingPin(int i, String s) {
                    Log.d(TAG, "[PinPad]One pin key is entered");
                }

                @Override
                public void onReadPinCancel() {
                    Log.d(TAG, "[PinPad]Canceled");

                    try {
                        callback.call(null);
                    } catch (Throwable e) {
                        Log.e(TAG, "onReadPinCancel", e);
                        send(MSG_CARD_ABORTED, "invalid_pin");
                    }
                }

                @Override
                public void onReadPinException() {
                    Log.d(TAG, "[PinPad]Exception occurred");

                    try {
                        callback.call(null);
                    } catch (Throwable e) {
                        Log.e(TAG, "onReadPinException", e);
                        send(MSG_CARD_ABORTED, "invalid_pin");
                    }
                }

                @Override
                public void onReadPinSuccess(byte[] bytes) {
                    Log.d(TAG, "[PinPad]Success");

                    try {
                        callback.call(HexUtil.bytesToHexString(bytes));
                    } catch (Throwable e) {
                        Log.e(TAG, "onReadPinSuccess", e);
                        send(MSG_CARD_ABORTED, "invalid_pin");
                    }
                }

                @Override
                public void onReadPinTimeout() {
                    Log.d(TAG, "[PinPad]Timeout");

                    try {
                        callback.call(null);
                    } catch (Throwable e) {
                        Log.e(TAG, "onReadPinTimeout", e);
                        send(MSG_CARD_ABORTED, "invalid_pin");
                    }
                }

                @Override
                public void onError(int i, String s) {
                    Log.d(TAG, "[PinPad]Error: " + i + ": " + s);

                    try {
                        callback.call(null);
                    } catch (Throwable e) {
                        Log.e(TAG, "onError", e);
                        send(MSG_CARD_ABORTED, "invalid_pin");
                    }
                }
            });
        } catch (Throwable e) {
            Log.e(TAG, "requestPin", e);
            send(MSG_CARD_ABORTED, "invalid_pin");
        }
    }

    private String readKernelData(byte[]... tag) {
        try {
            int size = 0;

            for (byte[] i : tag) {
                size += i.length;
            }

            ByteBuffer temp = ByteBuffer.allocate(size);

            for (byte[] i : tag) {
                temp.put(i);
            }

            byte[] tags = temp.array();
            Log.d(TAG, "[readKernelData] >>> [" + HexUtil.bcd2str(tags) + "]");
            byte[] kernelBytes = new byte[1024];
            size = pboc2.readKernelData(tags, kernelBytes);

            if (size <= 0) {
                Log.d(TAG, "Kernel read [null]");
                return null;
            }

            kernelBytes = Arrays.copyOfRange(kernelBytes, 0, size);
            String kernel = HexUtil.bcd2str(kernelBytes);
            Log.d(TAG, "[readKernelData] <<< [" + kernel + "]");
            return kernel;
        } catch (Throwable e) {
            Log.e(TAG, "readKernelData", e);
        }

        return null;
    }

    private void onlineProcessResult(String tags) throws RemoteException {
        /*
          [SDK 앱 원본]
            判断返回报文中的交易结果。
            按照如下导入联机结果：
            OnlineResult+[ iccresponse + ackdata ]
            【OnlineResult】：联机结果，1byte
            00：联机失败；
            01：联机成功；
            【iccresponse】：后台应答码，TLV格式，如8A023030，其中V为ASC码格式，2bytes，
            8A02固定，V取值如下：
            “00”：联机批准；
            “01”：发卡行语音参考；
            “05”：联机拒绝；
            【ackdata】:后台应答的55域数据，nbytes。如果解析出来有就加在30318A023030后面，没有就不加

          [번역]
            Determine the result of the transaction in the returned message.
            Import the online results as follows:
            OnlineResult+[ iccresponse + ackdata ]
             [OnlineResult]: online result, 1byte
            00: Online failed;
            01: Online success;
             [iccresponse]: background response code, TLV format, such as 8A023030, where V is ASC code format, 2bytes,
            8A02 is fixed, and the value of V is as follows:
             "00": online approval;
             "01": the issuing bank voice reference;
             "05": Online rejection;
            [ackdata]: 55 domain data answered in the background, nbytes. If it is parsed, it will be added after 30318A023030.
         */
        Log.d("GML_ICCEVT", "onlineProcessResult[" + tags + "]");
        String respCode = tags.substring(0, 2);
        String onlineData = tags.substring(2);
        pboc2.importOnlineResp(true, respCode, onlineData);
    }

    private void generateMac(String data, boolean useTDK) throws RemoteException {
        MacInfo info = new MacInfo(useTDK ? ID_TD_KEY : ID_TA_KEY, PinPadBuilder.MACMETHOD_TYPE.TYPE_BOC_EXTENED, PinPadBuilder.MAC_MODE.DEFAULT, data, null);
        byte[] out = pinPad.getMac(info); // 성공 시 8 바이트 배열을, 실패 시 null
        send(MSG_MAC_GENERATED, out != null ? "MAC generated" : "MAC generation failed", "mac", out != null ? HexUtil.bcd2str(out) : null);
    }

    public void getStatus(String name, IResult result) {
        switch (name) {
            case DeviceManager.DEVICE_CENTERM_PRINTER:
            case DeviceManager.DEVICE_CENTERM_IMAGE_PRINTER:
                result.set(getPrinterStatus());
                break;
            case DeviceManager.DEVICE_CENTERM_CARD:
                result.set(0);
                break;
        }
    }

    private int getPrinterStatus() {
        int result = 0;

        try {
            AidlNewPrinter printer = AidlNewPrinter.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_NEW_PRINTER));

            if (printer == null) {
                Log.w(TAG, "Printer service is null");
                return DeviceManager.STATUS_ERROR;
            }

            PrinterState state = printer.getPrinterState();
            Log.d(TAG, "Printer state: (" + state.getStateCode() + ") " + state.getStateMsg());

            switch (state.getStateCode()) {
                case DeviceErrorCode.DEVICE_PRINTER.DEVICE_OK:
                    break;
                case DeviceErrorCode.DEVICE_PRINTER.DEVICE_PRINTER_OUT_OF_PAPER:
                    result |= DeviceManager.STATUS_PAPER_EMPTY;
                    break;
                default:
                    result |= DeviceManager.STATUS_ERROR;
                    break;
            }
        } catch (Throwable e) {
            Log.e(TAG, "getPrinterStatus", e);
        }

        return result;
    }

    // CentermDeviceManager -> DeviceManager (이상 dev 모듈) -> DeviceManagerService -> CentermListener (이상 app 모듈)
    private void send(int what, String message, Object... args) {
        JSONObject json = new JSONObject();

        try {
            json.put("what", what);
            json.put("message", message);

            for (int i = 0; i + 1 < args.length; i += 2) {
                if (args[i + 1] != null) {
                    json.put((String) args[i], args[i + 1]);
                }
            }

            sender.sendMessage(DeviceManager.DEVICE_CENTERM_CARD, json.toString().getBytes());
        } catch (Throwable e) {
            Log.e(TAG, "send", e);
        }
    }

    private byte[] getOpenWayF55Tags() {
        try {
            ByteArrayOutputStream ous = new ByteArrayOutputStream();
            ous.write(EMVTAGS.combine(0x9f, 0x26));
            ous.write(EMVTAGS.combine(0x9f, 0x27));
            ous.write(EMVTAGS.combine(0x9f, 0x10));
            ous.write(EMVTAGS.combine(0x9f, 0x37));
            ous.write(EMVTAGS.combine(0x9f, 0x36));
            ous.write(EMVTAGS.combine(0x95));
            ous.write(EMVTAGS.combine(0x9a));
            ous.write(EMVTAGS.combine(0x9c));
            ous.write(EMVTAGS.combine(0x9f, 0x02));
            ous.write(EMVTAGS.combine(0x5f, 0x2a));
            ous.write(EMVTAGS.combine(0x82));
            ous.write(EMVTAGS.combine(0x9f, 0x1a));
            ous.write(EMVTAGS.combine(0x9f, 0x03));
            ous.write(EMVTAGS.combine(0x9f, 0x33));
            ous.write(EMVTAGS.combine(0x4f));
            ous.write(EMVTAGS.combine(0x9f, 0x08));
            ous.write(EMVTAGS.combine(0x9f, 0x34));
            ous.write(EMVTAGS.combine(0x9f, 0x35));
            ous.write(EMVTAGS.combine(0x9f, 0x1e));
            ous.write(EMVTAGS.combine(0x9f, 0x53));
            ous.write(EMVTAGS.combine(0x84));
            ous.write(EMVTAGS.combine(0x9f, 0x09));
            ous.write(EMVTAGS.combine(0x9f, 0x41));
            ous.write(EMVTAGS.combine(0x9f, 0x63));
            ous.write(EMVTAGS.combine(0x9f, 0x6e));
            ous.write(EMVTAGS.combine(0x9f, 0x4c));
            return ous.toByteArray();
        } catch (Throwable e) {
            Log.e(TAG, "getOpenWayF55Tags", e);
        }

        return new byte[0];
    }

    private byte[] getOpenWayDebug() {
        try {
            ByteArrayOutputStream ous = new ByteArrayOutputStream();
            ous.write(EMVTAGS.combine(0x9f, 0x27));     //Cryptogram Information Data
            ous.write(EMVTAGS.combine(0x95));           //Terminal Verification Results
            ous.write(EMVTAGS.combine(0x9f, 0x34));     //CVM Result
            ous.write(EMVTAGS.combine(0xdf, 0x31));     //Issuer Script Result
            ous.write(EMVTAGS.combine(0x9f, 0x39));     //07 = mChip Mode
            return ous.toByteArray();
        } catch (Throwable e) {
            Log.e(TAG, "getOpenWayDebug", e);
        }
        return new byte[0];
    }

    private byte[] getCardInfoTag() {
        try {
            ByteArrayOutputStream ous = new ByteArrayOutputStream();
            ous.write(EMVTAGS.combine(0x5a));
            ous.write(EMVTAGS.combine(0x5f, 0x34));
            ous.write(EMVTAGS.combine(0x57));
            ous.write(EMVTAGS.combine(0x5f, 0x20));
            ous.write(EMVTAGS.combine(0x9f, 0x12));
            ous.write(EMVTAGS.combine(0x50));
            return ous.toByteArray();
        } catch (Throwable e) {
            Log.e(TAG, "getCardInfoTag", e);
        }
        return new byte[0];
    }

    private byte[] getIssuerScriptResult() {
        try {
            ByteArrayOutputStream ous = new ByteArrayOutputStream();
            ous.write(EMVTAGS.combine(0xdf, 0x31));
            return ous.toByteArray();
        } catch (Throwable e) {
            Log.e(TAG, "getIssuerScriptResult", e);
        }

        return new byte[0];
    }

    private String extractOpenWayF55Tags(String kernel) {
        Log.d(TAG, "[extractOpenWayF55Tags]1. Extracting...");
        BerTlvParser parser = new BerTlvParser();
        BerTlvs tlvs = parser.parse(HexUtil.hexStringToByte(kernel));

        BerTlvBuilder builder = new BerTlvBuilder();
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x26));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x27));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x10));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x37));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x36));
        addIfExists(builder, tlvs, new BerTag(0x95));
        addIfExists(builder, tlvs, new BerTag(0x9a));
        addIfExists(builder, tlvs, new BerTag(0x9c));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x02));
        addIfExists(builder, tlvs, new BerTag(0x5f, 0x2a));
        addIfExists(builder, tlvs, new BerTag(0x82));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x1a));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x03));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x33));
        addIfExists(builder, tlvs, new BerTag(0x4f));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x08));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x34));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x35));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x1e));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x53));
        addIfExists(builder, tlvs, new BerTag(0x84));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x09));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x41));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x63));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x6e));
        addIfExists(builder, tlvs, new BerTag(0x9f, 0x4c));
        String extracted = HexUtil.bcd2str(builder.buildArray());

        Log.d(TAG, "[extractOpenWayF55Tags]2. Done [" + extracted + "]");
        return extracted;
    }

    private void addIfExists(BerTlvBuilder builder, BerTlvs tlvs, BerTag tag) {
        BerTlv tlv = tlvs.find(tag);

        if (tlv != null) {
            builder.addBerTlv(tlv);
        }
    }

    public boolean setTime(int year, int month, int day, int hour, int min, int sec) {
        try {
            AidlSystemSettingService service = AidlSystemSettingService.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_SYS));

            if (service == null) {
                Log.d(TAG, "System setting service is null");
                return false;
            }

            boolean success = service.setSystemTime(sec, min, hour, day, month, year);
            Log.d(TAG, "[setTime]" + (success ? "Success" : "Fail") + ": year=" + year + " month=" + month + " day=" + day + " hour=" + hour + " min=" + min + " sec=" + sec);
            return success;
        } catch (RemoteException e) {
            e.printStackTrace();
        }

        Log.d(TAG, "[setTime]Fail");
        return false;
    }

    public boolean powerReboot() {
        try {
            AidlSystemSettingService service = AidlSystemSettingService.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_SYS));

            if (service == null) {
                Log.d(TAG, "System setting service is null");
                return false;
            }

            service.powerReboot();
            Log.d(TAG, "power reboot success");
            return true;
        } catch (Throwable e) {
            Log.e(TAG, "powerReboot", e);
        }

        Log.d(TAG, "power reboot fail");
        return false;
    }

    public void startFastScan(final int what, final int token) {

        try {
            AidlQuickScanZbar scanner = AidlQuickScanZbar.Stub.asInterface(manager.getDevice(Constant.DEVICE_TYPE.DEVICE_TYPE_QUICKSCAN));

            if (scanner == null) {
                Log.d(TAG, "Scanner service is null");
                return;
            }

            scanner.init("com.centerm.smartpos");
            //cameraID           int     camera ID
            //width              int     width
            //height             int     height
            //lightMode          int     light Mode
            //time               int     timeout（ms）
            //spindegree         int     旋转角度（ScanQRCode接口无效）
            //beep               int     蜂鸣次数（ScanQRCode接口无效）
            //ExternalMap Key：
            //Persist            boolean is Persist
            //ShowPreview        boolean Show Preview
            //ScanEffect         boolean Scan Effect
            CameraBeanZbar cameraBean = new CameraBeanZbar(0, BEST_WIDTH, BEST_HEIGHT, 4, Integer.MAX_VALUE, SPIN_DEGREE, 1);
//            if (cameraBack) {
//                cameraBean.setCameraId(0);
//            } else {
//                cameraBean.setCameraId(1);
//            }
//            if (lightOpen) {
            cameraBean.setLightMode(2);
//            }
            cameraBean.setCameraId(0);

            cameraBean.setLightMode(0);

            HashMap<String, Object> externalMap = new HashMap<>();
            externalMap.put("ShowPreview", true);
            externalMap.put("ScanEffect", CAMERA_DISPLAY_EFFECT == 1);
//            externalMap.put("Charset", "1111");
//            externalMap.put("textStringDown", "1111");

            cameraBean.setExternalMap(externalMap);
            scanner.scanQRCode(cameraBean, new AidlScanCallback.Stub() {
                @Override
                public void onFailed(int arg0) {
//                    showMessage(getString(R.string.scan_fail));
//                    returnValue(false,null);
                    sendBarcode(what, token, -1, "");
                }

                @Override
                public void onCaptured(String arg0, int arg1) {
//                    showMessage(getString(R.string.scan_success) + "\n" + getString(R.string.scan_info) + "\n" + arg0);
//                    long SuccessEndTime = System.currentTimeMillis();
//                    long SuccessCostTime = SuccessEndTime - startTime;
//                    showMessage("time = " + SuccessCostTime);
//                    returnValue(true,arg0);
                    Log.e(TAG, "arg0 :" + arg0 + " arg1: " + arg1);
                    Log.e(TAG, "arg0 :" + stringToHex0x(arg0));

                    sendBarcode(what, token, 0, arg0);
                }
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // CentermDeviceManager -> DeviceManager (이상 dev 모듈) -> DeviceManagerService -> CentermListener (이상 app 모듈)
    private void sendBarcode(int what, int token, int result, String msg) {
        sender.sendMessage(what, token, result, msg);
    }

    public String stringToHex0x(String s) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            result.append(String.format("0x%02X ", (int) s.charAt(i)));
        }
        return result.toString();
    }

}
